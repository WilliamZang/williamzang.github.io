<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 函数式编程 | 臧成威的博客]]></title>
  <link href="http://williamzang.com/blog/categories/han-shu-shi-bian-cheng/atom.xml" rel="self"/>
  <link href="http://williamzang.com/"/>
  <updated>2017-02-04T13:20:16+08:00</updated>
  <id>http://williamzang.com/</id>
  <author>
    <name><![CDATA[臧成威]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[把玩高阶函数]]></title>
    <link href="http://williamzang.com/blog/2016/11/08/ba-wan-gao-jie-han-shu/"/>
    <updated>2016-11-08T13:19:42+08:00</updated>
    <id>http://williamzang.com/blog/2016/11/08/ba-wan-gao-jie-han-shu</id>
    <content type="html"><![CDATA[<p>如果你开始接触函数式编程，你一定听说过高阶函数。在维基百科它的中文解释是这样的：</p>

<blockquote><p>在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数：</p>

<ul>
<li><p>接受一个或多个函数作为输入</p></li>
<li><p>输出一个函数</p></li>
</ul>
</blockquote>

<p>看起它就是ObjC语言中入参或者返回值为block的block或者函数，在Swift语言中即为入参或者返回值为函数的函数。那它们在实际的开发过程中究竟起着什么样的作用呢？我们将从入参、返回值和综合使用三部分来看这个问题：</p>

<h2>函数作为入参</h2>

<p>函数作为入参似乎无论在ObjC时代还是Swift时代都是司空见惯的事情，例如<code>AFNetworking</code>就用两个入参block分别回调成功与失败。Swift中更是加了一个尾闭包的语法（最后一个参数为函数，可以不写括号或者写到括号外面直接跟随方法名），例如下面这样：</p>

<pre><code class="Swift">[1, 2, 3].forEach { item in  
    print(item)  
}  
</code></pre>

<p>我们可以将入参为函数的函数分为两类，escaping函数入参和noescape函数入参，区别在于这个入参的函数是在执行过程内被调用还是在执行过程外被调用。执行过程外被调用的一般用于callback用途，例如：</p>

<pre><code class="Swift">Alamofire.request("https://httpbin.org/get").responseJSON { response in  
    print(response.request)  // original URL request  
    print(response.response) // HTTP URL response  
    print(response.data)     // server data  
    print(response.result)   // result of response serialization  

    if let JSON = response.result.value {  
        print("JSON: \(JSON)")  
    }  
}
</code></pre>

<p>这个response的入参函数就作为网络请求回来的一个callback，并不会在执行responseJSON这个函数的时候被调用。另外我们来观察<code>forEach</code>的代码，可以推断入参的函数一定会在<code>forEach</code>执行过程中使用，执行完就没有利用意义，这类就是noescape函数。</p>

<p>callback的用法大家应该比较熟悉了，介绍给大家noescape入参的一些用法：</p>

<h3>1. 自由构造器</h3>

<p>看过GoF设计模式的同学不知道是否还记得构造器模式，Android中的构造器模式类似如下：</p>

<pre><code class="Java">new AlertDialog.Builder(this)  
  .setIcon(R.drawable.find_daycycle_icon)  
  .setTitle("提醒")  
  .create()  
  .show();
</code></pre>

<p>如果你想要做成这样的代码，你需要将<code>setIcon</code>、<code>setTitle</code>、<code>create</code>等方法都实现成返回<code>this</code>才行。这样就无法直接利用无返回值的<code>setter</code>了。
为什么需要这样的方式呢？如果你同时有如下需求：</p>

<ol>
<li>构造一个对象需要很多的参数</li>
<li>这些参数里面很多有默认值</li>
<li>这些参数对应的属性未来不希望被修改</li>
</ol>


<p>那么用这样的模式就可以直观又精巧的展示构建过程。</p>

<p>如果使用noescape入参函数还可以更简单的构造出这种代码，只需要传入一个入参为builder的对象就可以了，如下：</p>

<pre><code class="Swift">// 实现在这里  
class SomeBuilder {  
    var prop1: Int  
    var prop2: Bool  
    var prop3: String  
    init() {  
        // default value  
        prop1 = 0  
        prop2 = true  
        prop3 = "some string"  
    }  
}  

class SomeObj {  
    private var prop1: Int  
    private var prop2: Bool  
    private var prop3: String  
    init(_ builderBlock:(SomeBuilder) -&gt; Void) {  
        let someBuilder = SomeBuilder()  
        builderBlock(someBuilder) // noescape 入参的使用  
        prop1 = someBuilder.prop1  
        prop2 = someBuilder.prop2  
        prop3 = someBuilder.prop3  
    }  
}  

// 使用的时候  
let someOjb = SomeObj { builder in  
    builder.prop1 = 15  
    builder.prop2 = false  
    builder.prop3 = "haha"  
}
</code></pre>

<h3>2. 自动配对操作</h3>

<p>很多时候，我们开发过程中都会遇到必须配对才能正常工作的API，例如打开文件和关闭文件、进入edit模式退出edit模式等。虽然swift语言给我们defer这样的语法糖避免大家忘记配对操作，但是代码看起来还是不那么顺眼</p>

<pre><code class="Swift">func updateTableView1() {  
    self.tableView.beginUpdates()  

    self.tableView.insertRows(at: [IndexPath(row: 2, section: 0)], with: .fade)  
    self.tableView.deleteRows(at: [IndexPath(row: 5, section: 0)], with: .fade)  

    self.tableView.endUpdates() // 容易漏掉或者上面出现异常  

}  

func updateTableView2() {  
    self.tableView.beginUpdates()  
    defer {  
        self.tableView.endUpdates()  
    }  

    self.tableView.insertRows(at: [IndexPath(row: 2, section: 0)], with: .fade)  
    self.tableView.deleteRows(at: [IndexPath(row: 5, section: 0)], with: .fade)  
}  
</code></pre>

<p>利用noescape入参，我们可以将要操作的过程封装起来，使得上层看起来更规整</p>

<pre><code class="Swift">// 扩展一下UITableView  
extension UITableView {  
    func updateCells(updateBlock: (UITableView) -&gt; Void) {  
        beginUpdates()  
        defer {  
            endUpdates()  
        }  
        updateBlock(self)  
    }  
}  

func updateTableView() {  
    // 使用的时候  
    self.tableView.updateCells { (tableView) in  
        tableView.insertRows(at: [IndexPath(row: 2, section: 0)], with: .fade)  
        tableView.deleteRows(at: [IndexPath(row: 5, section: 0)], with: .fade)  
    }  
}  
</code></pre>

<p>函数作为入参就简单介绍到这里，下面看看函数作为返回值。</p>

<h2>函数作为返回值</h2>

<p>在大家的日常开发中，函数作为返回值的情况想必是少之又少。不过，如果能简单利用起来，就会让代码一下子清爽很多。</p>

<p>首先没有争议的就是我们有很多的API都是需要函数作为入参的，无论是上一节提到过的escaping入参还是noescape入参。所以很多的时候，大家写的代码重复率会很高，例如：</p>

<pre><code class="Swift">let array = [1, 3, 55, 47, 92, 77, 801]  

let array1 = array.filter { $0 &gt; 3 * 3}  
let array2 = array.filter { $0 &gt; 4 * 4}  
let array3 = array.filter { $0 &gt; 2 * 2}  
let array4 = array.filter { $0 &gt; 5 * 5}  
</code></pre>

<p>一段从数组中找到大于某个数平方的代码，如果不封装，看起来应该是这样的。为了简化，通常会封装成如下的两个样子：</p>

<pre><code class="Swift">func biggerThanPowWith(array: [Int], value: Int) -&gt; [Int] {  
    return array.filter { $0 &gt; value * value}  
}  

let array1 = biggerThanPowWith(array: array, value: 3)  
let array2 = biggerThanPowWith(array: array, value: 4)  
let array3 = biggerThanPowWith(array: array, value: 2)  
let array4 = biggerThanPowWith(array: array, value: 5)  
</code></pre>

<p>如果用高阶函数的返回值函数，可以做成这样一个高阶函数：</p>

<pre><code class="Swift">// 一个返回(Int)-&gt;Bool的函数  
func biggerThanPow2With(value: Int) -&gt; (Int) -&gt; Bool {  
    return { $0 &gt; value * value }  
}  

let array1 = array.filter(biggerThanPow2With(value: 3))  
let array2 = array.filter(biggerThanPow2With(value: 4))  
let array3 = array.filter(biggerThanPow2With(value: 2))  
let array4 = array.filter(biggerThanPow2With(value: 5))  
</code></pre>

<p>你一定会说，两者看起来没啥区别。所以这里面需要讲一下使用高阶返回函数的几点好处</p>

<h4>1. 不需要wrapper函数也不需要打开原始类</h4>

<p>如同上面的简单封装，其实就是一个wrapper函数，把<code>array</code>作为入参带入进来。这样写代码和看代码的时候就稍微不爽一点，毕竟大家都喜欢OOP嘛。如果要OOP，那就势必要对原始类进行扩展，一种方式是加extension，或者直接给类加一个新的方法。</p>

<h4>2. 阅读代码的时候一目了然</h4>

<p>使用简单封装的时候，看代码的人并不知道内部使用了<code>filter</code>这个函数，必须要查看源码才能知道。但是用高阶函数的时候，一下子就知道了使用了系统库的<code>filter</code>。</p>

<h4>3. 更容易复用</h4>

<p>这也是最关键的一点，更细粒度的高阶函数，可以更方便的复用，例如我们知道Set<Int>也是有<code>filter</code>这个方法的，复用起来就这样：</p>

<pre><code class="Swift">let set = Set&lt;Int&gt;(arrayLiteral: 1, 3, 7, 9, 17, 55, 47, 92, 77, 801)  
let set1 = set.filter(biggerThanPow2With(value: 3))  
let set2 = set.filter(biggerThanPow2With(value: 9))   
</code></pre>

<p>回忆下上面的简单封装，是不是就无法重用了呢？</p>

<p>类似的返回函数的高阶函数还可以有很多例子，例如上面说过的builder，假如每次都需要定制成特殊的样子，但是某个字段不同，就可以用高阶函数很容易打造出来：</p>

<pre><code class="Swift">func builerWithDifferentProp3(prop3: String) -&gt; (SomeBuilder) -&gt; Void {  
    return { builder in  
        builder.prop1 = 15  
        builder.prop2 = true  
        builder.prop3 = prop3  
    }  
}  

let someObj1 = SomeObj.init(builerWithDifferentProp3(prop3: "a"))  
let someObj2 = SomeObj.init(builerWithDifferentProp3(prop3: "b"))  
let someObj3 = SomeObj.init(builerWithDifferentProp3(prop3: "c"))  
</code></pre>

<p>介绍完入参与返回值，还有另外的一个组合模式，那就是入参是一个函数，返回值也是一个函数的情况，我们来看看这种情况。</p>

<h2>入参函数 &amp;&amp; 返回值函数</h2>

<p>这样的一个函数看起来会很恐怖，swift会声明成<code>func someFunc&lt;A, B, C, D&gt;(_ a: (A) -&gt; B)-&gt; (C) -&gt; D</code>，objective-c会声明成<code>- (id (^)(id))someFunc:(id (^)(id))block</code>。让我们先从一个小的例子来讲起，回忆一下我们刚刚做的<code>biggerThanPow2With</code>这个函数，如果我们要一个<code>notBiggerThanPow2With</code>怎么办呢？你知道我一定不会说再写一个。所以我告诉你我会这样写：</p>

<pre><code class="Swift">func not&lt;T&gt;(_ origin_func: @escaping (T) -&gt; Bool) -&gt; (T) -&gt; Bool {  
    return { !origin_func($0) }  
}  

let array5 = array.filter(not(biggerThanPow2With(value: 9)))  
</code></pre>

<p>并不需要一个<code>notBiggerThanPow2With</code>函数，我们只需要实现一个<code>not</code>就可以了。它的入参是一个<code>(T) -&gt; Bool</code>，返回值也是<code>(T) -&gt; Bool</code>，只需要在执行block内部的时候用个取反就可以了。这样不单可以解决刚才的问题，还可以解决任何<code>(T) -&gt; Bool</code>类型函数的取反问题，比如我们有一个<code>odd(_: int)</code>方法来过滤奇数，那我们就可以用<code>even=not(odd)</code>得到一个过滤偶数的函数了。</p>

<pre><code class="Swift">func odd(_ value: Int) -&gt; Bool {  
    return value % 2 == 1  
}  

let array6 = array.filter(odd)  
let array7 = array.filter(not(odd))  

let even = not(odd)  
let array8 = array.filter(even)  
</code></pre>

<p>大家可以看下上面的<code>biggerThanPow2With</code>时我们讨论过的，如果<code>biggerThanPow2With</code>不是一个返回函数的高阶函数，那它就不太容易用<code>not</code>函数来加工了。</p>

<p>综上，如果一个入参和返回值都是函数的函数就是这样的一个转换函数，它能够让我们用更少的代码组合出更多的函数。另外需要注意一下，如果返回的函数里面闭包了入参的函数，那么入参函数就是escaping入参了。</p>

<p>下面再展示给大家两个函数，一个交换参数的函数<code>exchangeParam</code>，另一个是柯里化函数<code>currying</code>：</p>

<pre><code class="Swift">func exchangeParam&lt;A, B, C&gt;(_ block: @escaping (A, B) -&gt; C) -&gt; (B, A) -&gt; C {  
    return { block($1, $0) }  
}  

func currying&lt;A, B, C&gt;(_ block: @escaping (A, B) -&gt; C, _ value: A) -&gt; (B) -&gt; C {  
    return { block(value, $0) }  
}  
</code></pre>

<p>第一个函数<code>exchangeParam</code>是交换一个函数的两个参数，第二个函数<code>currying</code>是给一个带两个参数的函数和一个参数，返回一个带一个参数的函数。那这两个函数究竟有什么用途呢？看一下下面的例子：</p>

<pre><code class="Swift">let array9 = array.filter(currying(exchangeParam(&gt;), 9))
</code></pre>

<p>swift语言里面<code>&gt;</code>是一个入参(a, b)的函数，所以<code>&gt;(5, 3) == true</code>。我们使用<code>exchangeParam</code>交换参数就变成了(b, a)，这时<code>exchangeParam(&gt;)(5, 3)</code>就等于<code>false</code>了。</p>

<p>而currying函数又把参数<code>b</code>固定为一个常量9，所以<code>currying(exchangeParam(&gt;), 9)</code>就是大于9的函数意思。</p>

<p>这个例子里就利用了全部的预制函数和通用函数，没有借助任何的命令与业务函数声明实现了一个从数组中过滤大于9的子数组的需求。试想一下，如果我们更多的使用这样的高阶函数，代码中是不是很多的逻辑可以更容易的互相组合，而这就是函数式编程的魅力。</p>

<h2>总结</h2>

<p>高阶函数的引入，无论是从函数式编程还是从非函数式编程都带给我们代码一定程度的简化，使得我们的API更加简易可用，复用更充分。然而本文的例子不过是冰山一角，更多的内容还需要大家的不断尝试和创新，也可以通过学习更多的函数式编程范式来加深理解。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[聊一聊iOS开发中的惰性计算]]></title>
    <link href="http://williamzang.com/blog/2016/11/07/liao-yi-liao-ioskai-fa-zhong-de-duo-xing-ji-suan/"/>
    <updated>2016-11-07T21:56:25+08:00</updated>
    <id>http://williamzang.com/blog/2016/11/07/liao-yi-liao-ioskai-fa-zhong-de-duo-xing-ji-suan</id>
    <content type="html"><![CDATA[<p>首先给大家讲一个笑话：</p>

<blockquote><p>有一只小白兔，跑到蔬菜店里问老板：“老板，有100个胡萝卜吗？”。老板说：“没有那么多啊。”，小白兔失望的说道：“哎，连100个胡萝卜都没有。。。”。<br/>
第二天小白兔又来到蔬菜店问老板：“今天有100个胡萝卜了吧？”，老板尴尬的说：“今天还是缺点，明天就能好了。”，小白兔又很失望的走了。<br/>
第三天小白兔刚一推门，老板就高兴的说道：“有了有了，从前天就进货的100个胡萝卜到货了。”，小白兔说：“太好了，我要买2根！”。。。</p></blockquote>

<p>不晓得笑话是否博您一笑，但是这里面确有一个点是和我们的主题惰性计算相关的。试想一下，假设蔬菜店是一个电商，你是老板，你挂商品数量的时候，是100个，1000个，还是真实的备货2个？显然做过淘宝的同学都知道这其中的玄机，就是先挂大的余量，有卖出再补货。所以，如果这个老板先回答有100个胡萝卜，再等它要2个的时候把自己备货的2个拿给它，是不是就免去了100个胡萝卜的物流？</p>

<p>在程序开发中，我们也会经常的遇到这样的问题，明明创建了很大的一个对象，但是其实只用了一个字段；明明创建了一个500个的数组，其实只用了第0个和第1个元素。遇到这类问题，我们可以尝试使用惰性计算来解决。</p>

<p>关于惰性计算，或者惰性求值。想必大家第一反应就是在getter里动态返回属性了。例如有一个很大的属性，你希望在有人调用的时候才创建，就可以这样写：</p>

<pre><code class="objective-c">- (id)someBigProperty
{
    if (_someBigProperty == nil) {
        NSMutableArray *someBigProperty = [NSMutableArray array];
        for (int i = 0; i &lt; 100000; ++i) {
            [someBigProperty addObject:@(i)];
        }
        _someBigProperty = [someBigProperty copy];
    }

    return _someBigProperty;
}
</code></pre>

<p>本文当然不拘泥于大家耳熟能详的知识点进行阐述了。上述的代码虽然也能勉强叫惰性求值，但并非足够理想。为什么说是“勉强叫”呢？大家想想上面的笑话，其实这样做和老板的做法并无差别。首先店里没有100个胡萝卜，就好像这个对象没有<code>_someBigProperty</code>属性一样。一旦有人需要100个“胡萝卜”，就循环100000次创建这个<code>_someBigProperty</code>属性。然后可能使用者只需要第0个。</p>

<p>另外在实际项目中这样的一个手段几乎被大家严重的乱用了，为什么说是乱用呢？除了创建非常大的属性、或者创建对象的时候有一些必要的副作用不能提前创建之外，几乎不应该使用惰性求值来处理类似逻辑。原因如下：</p>

<ul>
<li>如果真的是很大的属性，一般它比较重要，很可能会被访问，要不要在getter中写出来意义不大。</li>
<li>@property的atomic、nonatomic、copy、strong等描述在有getter方法的属性上会失效，后人修改代码的时候可能只改了@property声明，并不会记得改getter，于是隐患就这样埋下了。</li>
<li>代码含有了隐私操作，尤其getter中再混杂了各种逻辑，使得程序出现问题非常不好排查。后人哪会想到<code>someObj.someProperty</code>这样一个简简单单的取属性发生了很多奇妙的事。</li>
<li>代码多，本来代码只需要在<code>init</code>方法中创建用上一两行，结果用了至少7行的一个getter方法才能写出来，想想一个程序轻则数百个属性，都这么搞，得多出多少行代码？另外代码格式几乎完全一样，不符合DRY原则。好的程序员不应该总是写重复的代码，不是么？（某人说一个程序里面，20-30个属性已经算非常多了，只能是眼界问题了）</li>
<li>性能损耗，对于属性取值可能会非常的频繁，如果所有的属性取值之前都经过一个<code>if</code>判断，这不是平白浪费的性能？</li>
</ul>


<p>我们回到正题。既然简单改写一下getter不但解决不了问题还有这么多隐患，那我们该如何能够正确优雅的把惰性计算写好？下面给大家一些建议。</p>

<p>观察上面的代码，你会发现_someBigProperty是一个非常规则的NSArray，它的item内容与下标相等。我们可以看出item的结果与index存在如下关系：</p>

<blockquote><p>f(x) = x</p></blockquote>

<p>类似的可以有很多，例如<code>&gt; 100</code>的为<code>@“world”</code>，<code>0 &lt;= x &lt;= 100</code>的为<code>@“hello”</code>；item为下标的平方；item为下标的数值转换成的字符串等。所以这类<code>NSArray</code>，基本需要一个count和一个函数就可以构成了。那我们现在就基于<code>NSArray</code>这个类簇，实现一个特殊的类吧！</p>

<p>关于类簇，相信很多同学都有所了解，大概的说法是不可以直接继承一个<code>NSArray</code>、<code>NSNumber</code>、<code>NSString</code>这样的类。如果要继承需要实现全部的必要方法，在<code>NSArray</code>这个类簇来说，就是如下的方法：</p>

<pre><code class="objective-c">@interface NSArray&lt;__covariant ObjectType&gt; : NSObject &lt;NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration&gt;

@property (readonly) NSUInteger count;
- (ObjectType)objectAtIndex:(NSUInteger)index;
- (instancetype)init NS_DESIGNATED_INITIALIZER;
- (instancetype)initWithObjects:(const ObjectType [])objects count:(NSUInteger)cnt NS_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;

@end
</code></pre>

<p>当然除了<code>NSArray</code>类的基本方法，还有<code>NSCopying</code>、<code>NSMutableCopying</code>、<code>NSSecureCoding</code>这些协议需要实现，另外<code>NSFastEnumberation</code>协议已经默认实现完成，不需要额外处理。与惰性计算无关的细节大家可以自己填补，对于本例，我们只需要关心这几个方法的实现：</p>

<pre><code class="objective-c">
typedef id(^ItemBlock)(NSUInteger index);

@interface ZDynamicArray : NSArray

- (instancetype)initWithItemBlock:(ItemBlock)block count:(NSUInteger)cnt;
- (id)objectAtIndex:(NSUInteger)index;
- (NSUInteger)count;
@end
</code></pre>

<p>按照上文的说法，对于这样一个特殊的<code>NSArray</code>，我们真正要储存的数据只有一个count值外加一个函数，所以我们用这两个作为<code>init</code>参数。实现也很简单：</p>

<pre><code class="objective-c">@interface ZDynamicArray()

@property (nonatomic, readonly) ItemBlock block;
@property (nonatomic, readonly) NSUInteger cnt;
@end

@implementation ZDynamicArray

- (instancetype)initWithItemBlock:(ItemBlock)block count:(NSUInteger)cnt
{
    if (self = [super init]) {
        _block = block;
        _cnt = cnt;
    }
    return self;
}

- (NSUInteger)count
{
    return self.cnt;
}

- (id)objectAtIndex:(NSUInteger)index
{
    if (self.block) {
        return self.block(index);
    } else {
        return nil;
    }
}

@end 
</code></pre>

<p>瞧，就这么简单的写好了。让我们试一下吧！</p>

<pre><code class="objective-c">ZDynamicArray *array = [[ZDynamicArray alloc] initWithItemBlock:^id(NSUInteger index) {
    return @(index);
} count:100000];

for (id v in array) {
    NSLog(@"%@", v);
}

NSLog(@"%@", array[15]);
</code></pre>

<p>一个看似10w数据的数组，其实占用空间微乎其微，但是作用和最开始那样的代码效果一样。很不错吧。大家也可以动手实践，写一些自己需要用到的惰性计算代码，例如一个<code>Model</code>的数组，并非所有的<code>Model</code>都需要用到，我们也可以做成这样的一个数组，等用到的时候再从<code>NSDicitonary</code>转换成<code>Model</code>。就像这样：</p>

<pre><code class="objective-c">NSArray *downloadData = @[@{}, @{}, @{}, @{}];

NSArray *modelArray = [[ZDynamicArray alloc] initWithItemBlock:^id(NSUInteger index) {
    return [SomeModel modelFromDictionary:downloadData[index]];
} count:downloadData.count];    
</code></pre>

<p>好了，惰性计算就说到这里了。大家善加利用，一定可以写一些好玩的东西的。</p>
]]></content>
  </entry>
  
</feed>
