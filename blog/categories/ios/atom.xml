<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 臧成威的博客]]></title>
  <link href="http://williamzang.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://williamzang.com/"/>
  <updated>2014-09-05T16:52:07+08:00</updated>
  <id>http://williamzang.com/</id>
  <author>
    <name><![CDATA[臧成威]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[聊一聊RAC]]></title>
    <link href="http://williamzang.com/blog/2014/08/20/talk-about-rac/"/>
    <updated>2014-08-20T11:17:32+08:00</updated>
    <id>http://williamzang.com/blog/2014/08/20/talk-about-rac</id>
    <content type="html"><![CDATA[<p>今天来聊一聊RAC，这个在Github上很火热的开源框架，相信很多关注iOS前沿开发的人都或多或少的知道。</p>

<p>关于RAC的介绍和一些概念，我这里就不再啰嗦了，大家可以看   <a href="http://limboy.me/about.html">limboy</a>的几篇关于RAC的介绍，很不错。</p>

<blockquote><p><a href="http://limboy.me/ios/2013/06/19/frp-reactivecocoa.html">ReactiveCocoa与Functional Reactive Programming</a><br/>
<a href="http://limboy.me/ios/2013/12/27/reactivecocoa-2.html">说说ReactiveCocoa 2</a><br/>
<a href="http://limboy.me/ios/2014/01/05/ios-rest-client-implementation.html">基于AFNetworking2.0和ReactiveCocoa2.1的iOS REST Client</a><br/>
<a href="http://limboy.me/tech/2014/06/06/deep-into-reactivecocoa2.html">ReactiveCocoa2实战</a></p></blockquote>

<p>此外还有Cocoachina的一系列教程<a href="http://www.cocoachina.com/cms/plus/view.php?aid=8905">Reactive Cocoa详解</a></p>

<p>写Blog，在我看来和开发一样，也要讲究重用，引用列位的信息即可，何必黏贴和表达类似的观点。这里我也仅说一下我自己的理解和看法。</p>

<p>相信很多人都尝试过RAC用到一些小的DEMO或者项目中的一个小部分然后就浅尝辄止了。为什么呢？我觉得主要在于，RAC实际推行的一种新的概念大家还没有习惯，那就是函数响应式编程FRP。<a href="https://github.com/staltz">staltz</a>在一个Gist上倒是给了一个比较全面的解释<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">The introduction to Reactive Programming you&rsquo;ve been missing</a>，可惜是英文的。</p>

<p>这种FRP的核心就在于数据流，FRP把整个的程序认为是数据流的转换，既不是过程、也不是对象。一个系统先产生信号，转换信号，然后业务和界面再接收和响应信号的变化。所以，这是一个新的概念。如果使用别的概念套用，自然用起来就没那么顺手了。那么我们来看看，这样做的好处是什么呢？</p>

<ul>
<li>统一的流处理模式，使得不同的组件可以很好的结合起来，例如iOS的<code>UserDefault</code>、<code>NSNotificationCenter</code>、<code>KVO</code>这些，在RAC库下面，都是相同的封装，这样就使得上层的业务逻辑实现了<strong>大同</strong>，进而一切的信号转换合并都可以有效的结合在一起。</li>
<li>处理异步，很多时候，我们对于异步再同步是比较头大的。而RAC中，一个信号的终止，是不局限在一个函数中的。这样我们可以把不同线程、不同时期的状态绑到一个信号上，使得使用者达到一种内聚。和这种内聚，在转换和迭代的过程中是很必要的。</li>
<li>统一的错误处理，从古老的C时代的<code>int DoSomeThine(int input1, int *output1)</code>这种以返回值返回错误，到后来<code>SetErrorStatus(int ErrorCode, const char *message)</code>的线程栈内全局报错机制，还有现在try-catch机制，都有一个很要命的问题，就是错误处理，或者是可以被忽略，或者是让开发变得很烦恼。Java的try-catch机制，相信Java的开发者们一定深有感触。而RAC把错误变得简单了，它对于错误的处理，会随着变化一起传递到顶层，既不会忘记，也不用在中间环节中手动传递来传递去。</li>
<li>逻辑的拆分，在FRP中，逻辑变得相对独立，通常是一个模块，根据一定的变化产生一个信号，亦或是一个模块，根据一个传入的信号，产生一定的转换。这就使得，我们可以只返回我们的直接结果，后期的加工和变更是分离的。对于上层模块，也只关注信号的类型，不关注处于那个线程还是何种手法。</li>
</ul>


<p>总而言之，RAC给与我们以数据的变化作为出发点，界面与之响应的一套框架。详细的一些技巧，我会在后续的blog中为大家慢慢介绍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[介绍一下开源项目FastAnimationWithPOP]]></title>
    <link href="http://williamzang.com/blog/2014/07/23/jie-shao-yi-xia-kai-yuan-xiang-mu-fastanimationwithpop/"/>
    <updated>2014-07-23T16:07:04+08:00</updated>
    <id>http://williamzang.com/blog/2014/07/23/jie-shao-yi-xia-kai-yuan-xiang-mu-fastanimationwithpop</id>
    <content type="html"><![CDATA[<p>这是一个很简单的动画框架，基于Facebook的POP库。使用它你就可以在故事版中以0行代码的代价来添加动画了。</p>

<p>Github上地址是 <a href="https://github.com/WilliamZang/FastAnimationWithPOP">这里</a>.</p>

<p>你可以从<a href="https://github.com/WilliamZang/FastAnimationWithPopDemo">这里</a>下载DEMO查看效果.</p>

<p><strong>如果你觉得不错，欢迎在到<a href="https://github.com/WilliamZang/FastAnimationWithPOP">这里</a>点个赞，方便让更多人注意到它</strong></p>

<p><img src="https://raw.githubusercontent.com/WilliamZang/FastAnimationWithPOP/master/Docs/demo.gif" alt="Demo" /></p>

<h2>功能</h2>

<ul>
<li>使用属性来添加一个动画到任意的View。</li>
<li>在nib或者故事版唤醒时自动执行动画。</li>
<li>也可以随时手动执行动画。</li>
<li>控制动画的细节。</li>
<li>给control绑定一些动画，例如按下松开等状态。</li>
<li>轻松的扩展新的动画，只需要实现<code>FastAnimationProtocol</code>、<code>ControlFastAnimationProtocol</code> 和 <code>FastAnimationReverseProtocol</code>这几个协议.</li>
</ul>


<h2>环境要求</h2>

<p>iOS SDK: iOS 6.0+</p>

<p>XCode版本: 5.0+</p>

<h2>如何安装</h2>

<p>最好的办法是使用<a href="http://cocoadocs.org">CocoaPods</a>:</p>

<ol>
<li><p>添加这行到你的<code>podfile</code>文件 <code>pod 'FastAnimation'</code></p></li>
<li><p>安装更新 <code>pod install</code></p></li>
</ol>


<p>如果想要尝试最新的版本，你可以添加这个<code>pod 'FastAnimation', :head</code>.</p>

<h2>使用指导</h2>

<h3>1. 在故事板里使用</h3>

<p>你可以通过设置用户自定义运行时属性(user defined runtime attributes)给View添加一个动画。</p>

<p><img src="https://raw.githubusercontent.com/WilliamZang/FastAnimationWithPOP/master/Docs/stroyBoard1.png" alt="StroyBoard1" /></p>

<p><img src="https://raw.githubusercontent.com/WilliamZang/FastAnimationWithPOP/master/Docs/stroyBoard2.png" alt="StroyBoard2" /></p>

<p>下面是一些属性的含义：</p>

<h4>UIView的属性</h4>

<ul>
<li><p>animationType</p>

<p>  通过这个属性来指定动画的类型，可以是完整的类名，也可以省略<code>FAAnimation</code>前缀.</p></li>
<li><p>delay</p>

<p>  执行动画的延时，以秒为单位。</p></li>
<li><p>animationParams</p>

<p>  这个是各个动画的灵活参数，你可以从动画类的头文件中找到信息，例如下面：</p></li>
</ul>


<p>&#8220;`objective-c</p>

<h1>define kSpringBounciness   (@&ldquo;animationParams.springBounciness&rdquo;)</h1>

<h1>define kSpringSpeed        (@&ldquo;animationParams.springSpeed&rdquo;)</h1>

<h1>define kDynamicsTension    (@&ldquo;animationParams.dynamicsTension&rdquo;)</h1>

<h1>define kDynamicsFriction   (@&ldquo;animationParams.dynamicsFriction&rdquo;)</h1>

<h1>define kDynamicsMass       (@&ldquo;animationParams.dynamicsMass&rdquo;)</h1>

<p>&#8220;`</p>

<ul>
<li><p>startAnimationWhenAwakeFromNib</p>

<p>  定义是否需要在故事板唤醒的时候就执行动画，默认是<code>YES</code>。</p></li>
</ul>


<h4>UIControl的属性</h4>

<ul>
<li><p>bindingAnimationType</p>

<p>  通过这个属性来指定控件动画的类型，可以是完整的类名，也可以省略<code>FAAnimation</code>前缀.</p></li>
</ul>


<h3>2. 代码写View的应用</h3>

<p>在代码写View中使用FastAnimation同样方便。</p>

<p>你可以设置动画类型等属性，然后执行<code>- (void)startFAAnimation</code>即可。就像这样：</p>

<p><code>objective-c
UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
view.backgroundColor = [UIColor redColor];
view.animationType = @"Shake";
view.animationParams[@"velocity"] = @-7000;
// You can also set params like this
// [view setValue:@-7000 forKeyPath:kShakeVelocity];
[view startFAAnimation];
</code></p>

<p>还有这些扩展的用法：</p>

<p><code>objective-c
// In UIView instance.
- (void)startFAAnimation;
- (void)reverseFAAnimation;
// In UIControl instance.
- (void)bindingFAAnimation;
- (void)unbindingFAAnimation;
</code></p>

<h3>3. 定义一个新的动画扩展</h3>

<p>轻松的扩展新的动画，只需要实现<code>FastAnimationProtocol</code>、<code>ControlFastAnimationProtocol</code> 和 <code>FastAnimationReverseProtocol</code>这几个协议.</p>

<p>就像这样：</p>

<p>&#8220;`objective-c
// new_animation.h
@interface FAAnimationNewAnimation : NSObject&lt;FastAnimationProtocol,
FastAnimationReverseProtocol> // Maybe only FastAnimationProtocol</p>

<p>@end
// new_animation.m
@implementation FAAnimationBounceRight</p>

<ul>
<li><p>(void)performAnimation:(UIView *)view
{
  // some thing you like.
}</p></li>
<li><p>(void)stopAnimation:(UIView *)view
{
  // some thing you like.
}</p></li>
<li><p>(void)reverseAnimation:(UIView *)view
{
   // some thing you like.
}</p></li>
<li><p>(void)stopReverse:(UIView *)view
{
   // some thing you like.
}
@end</p></li>
</ul>


<p>&#8220;`</p>

<h3>4. 一些控制动画的操作</h3>

<ul>
<li>停止动画：</li>
</ul>


<p>如果想要手动体制，使用下面的方法：</p>

<p><code>objective-c
- (void)stopFAAnimation;
- (void)stopReverseFAAnimation;
</code></p>

<ul>
<li>嵌套动画：</li>
</ul>


<p>使用如下方法处理嵌套：</p>

<p><code>objective-c
- (void)startFAAnimationNested;
- (void)stopFAAnimationNested;
- (void)reverseFAAnimationNested;
- (void)stopReverseFAAnimationNested;
</code></p>

<h3>目前已经拥有的动画:</h3>

<ul>
<li>反弹动画（4方向）: <code>BounceLeft</code>,<code>BounceRight</code>,<code>BounceUp</code>,<code>BounceDown</code></li>
<li>放大动画（2方向）：<code>ZoomInX</code>,<code>ZoomInY</code></li>
<li>颤动动画</li>
<li>组动画</li>
<li>放大动画</li>
<li>Button的放大效果绑定</li>
<li><strong>更多的动画等着大家的贡献哟！</strong></li>
</ul>


<h2>下一步要做的事</h2>

<ul>
<li>把DEMO和库项目和到同一个Workspace里。</li>
<li>制作更多更好看的DEMO。</li>
<li>假如便捷的转场动画，目前先设法支持iOS7+</li>
<li>确保所有的功能都含有单元测试。</li>
<li>更多更好的动画。</li>
<li>把核心部分和效果部分分离，效果按照iOS5 6 7+来打成不同的包.</li>
<li>支持Swift写扩展.</li>
</ul>

]]></content>
  </entry>
  
</feed>
