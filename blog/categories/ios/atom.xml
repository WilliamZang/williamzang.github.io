<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 臧成威的博客]]></title>
  <link href="http://williamzang.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://williamzang.com/"/>
  <updated>2014-09-09T12:16:40+08:00</updated>
  <id>http://williamzang.com/</id>
  <author>
    <name><![CDATA[臧成威]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[从另一个角度介绍下Block]]></title>
    <link href="http://williamzang.com/blog/2014/09/09/cong-ling-yi-ge-jiao-du-jie-shao-xia-block/"/>
    <updated>2014-09-09T10:27:24+08:00</updated>
    <id>http://williamzang.com/blog/2014/09/09/cong-ling-yi-ge-jiao-du-jie-shao-xia-block</id>
    <content type="html"><![CDATA[<p>群里有个小伙伴问我block的理解，我想网上那么多blog都写过iOS的block的介绍，说明，用法，如果还是不能理解，那就换个角度吧。所以，今天我们来聊一聊Block的前世今生，不谈block如何定义，不谈block有哪些坑，之谈它是怎么来的。</p>

<p>首先block的使用，真的不必多说，想必大家google后也都会用。问题就在于，为什么要有block？有人觉得block方便，到底方便在哪里呢？这一切要从函数指针这个很老的概念谈起了。</p>

<p>在C时代，面向过程一度成为程序开发的主流，在没有对象化的程序设计中，我们难免写出如下的程序：</p>

<p>&#8220;`c
extern const char <em>GetMenu0();
extern const char </em>GetMenu1();
extern const char <em>GetMenu2();
extern const char </em>GetMenu3();
extern const char <em>GetMenu4();
extern const char </em>GetMenu5();</p>

<p>const char *GetMenuShow(int pos) {</p>

<pre><code>switch (pos) {
    case 0: return GetMenu0();
    case 1: return GetMenu1();
    case 2: return GetMenu2();
    case 3: return GetMenu3();
    case 4: return GetMenu4();
    case 5: return GetMenu5();
    default:
        return NULL;
}
</code></pre>

<p>}
&#8220;`</p>

<p>随着程序的复杂度提高，这样的程序变得越来越长，这时函数指针可以来帮忙，于是函数就变成了这样：</p>

<p>&#8220;`c
extern const char <em>GetMenu0();
extern const char </em>GetMenu1();
extern const char <em>GetMenu2();
extern const char </em>GetMenu3();
extern const char <em>GetMenu4();
extern const char </em>GetMenu5();</p>

<p>typedef const char <em>(</em>MenuMethodType)();</p>

<p>static MenuMethodType g_methods[] = {
  &amp;GetMenu0,
  &amp;GetMenu1,
  &amp;GetMenu2,
  &amp;GetMenu3,
  &amp;GetMenu4,
  &amp;GetMenu5
};</p>

<p>const char *GetMenuShow(int pos) {</p>

<pre><code>if (pos &lt; 0 || pos &gt;= (sizeof(g_methods) / sizeof(MenuMethodType))) {
    return NULL;
}
return g_methods[pos]();
</code></pre>

<p>}
&#8220;`</p>

<p>这种写法也叫做跳转表，好处是以后GetMenu*这种函数的增长可以放到GetMenuShow这个函数外，减少了耦合。函数指针的另一个妙用就是回调函数，这个非常的普遍，也不需要再举例子了。</p>

<p>函数指针给我们带来的新的开发思想，就是行为的变量化，因此，我们可以将不同的行为封装到统一的流程之外，作为可替换的组件。总之，它允许你把可变化的行为，注入到稳定的过程中，我们便获得了更好的扩展，把开发的中心放到变化而不是重复上。</p>

<p>到了OC时代，OC有了一种比函数指针还高效而简单的东西，那就是selector。这个被称为选择器的工具，不仅可以让我们得到函数指针的一切便利，还可以动态的替换其指向的内容。于是我们有了很多<code>addTarget:action:</code>这样的API，使得我们可以把行为注入到已经非常稳定的Cocoa或CocoaTouch框架中。</p>

<p>虽然有了一定的便利，但是程序员是不容易满足的。我们逐渐发现，这种基于action的写法有时很麻烦。主要是以下几点：</p>

<ol>
<li>就是很多时候，你注入的内容可能就一次，搞一个函数或者方法，浪费了不少的时间。</li>
<li>你还要起名字，要知道，Phil Karlton就说过:“在计算机科学领域,有两大难题,如何验证缓存和如何给各种东西命名。”</li>
<li>使得你原本可以在一个函数里实现的逻辑，分散到不同的部分，你难以专注的一次把你的逻辑写完。</li>
</ol>


<p>这时，我们的主角block就来帮助大家了。</p>

<p>其实block还有很多别名，其中一个就是匿名函数。利用block，你可以在一个函数中，写上一小段代码，不用起名字，就可以传递过去。函数指针的用法，几乎都可以用匿名函数来替换。一举解决了碎片化，命名等问题。我们便有了这样的代码：</p>

<p>&#8220;`objective-c
AFHTTPRequestOperationManager <em>manager = [AFHTTPRequestOperationManager manager];
[manager GET:@&ldquo;<a href="http://example.com/resources.json">http://example.com/resources.json</a>&rdquo; parameters:nil success:^(AFHTTPRequestOperation </em>operation, id responseObject) {</p>

<pre><code>NSLog(@"JSON: %@", responseObject);
</code></pre>

<p>} failure:^(AFHTTPRequestOperation <em>operation, NSError </em>error) {</p>

<pre><code>NSLog(@"Error: %@", error);
</code></pre>

<p>}];</p>

<p>&#8220;`</p>

<p>贪婪的程序员不仅仅满足于少起个名字和把代码写到一起，一旦程序员们发现，把一个函数写在另一个函数里很爽，就开始频繁的尝试。这时，又发现了几个小问题（以下仅是匿名函数的问题，block解决了这些问题）：</p>

<ol>
<li>匿名函数，到底还是一个函数，这个括号外面世界的变量，是不可以在里面使用的。</li>
<li>由于只能传递一个函数，我们就没有了可操作的对象（即没有了self）。</li>
</ol>


<p>其实这两个是一样的问题，都是因为没有变量的传递。如果可以把self传递下来，第二个问题也解决了。</p>

<p>想要解决这个问题，最简单的方法就是搞到全局域，于是代码就写成了这样：</p>

<p>&#8220;`objective-c
static int g_sum = 0;</p>

<ul>
<li><p>(BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{
  g_sum = 0;
  [@[@1, @2, @3] enumerateObjectsUsingBlock:^(NSNumber <em>obj, NSUInteger idx, BOOL </em>stop) {
      int val = [obj intValue];
      g_sum += val;
  }];
  NSLog(@&ldquo;sum = %d&rdquo;, g_sum);</p>

<p>  // Override point for customization after application launch.
  return YES;
}
&#8220;`</p></li>
</ul>


<p>把想要在匿名函数中的部分先存到全局变量，然后再到匿名函数中取出来。我们原本想解决的碎片化问题，又回来了。这样情况下，我们不得不搞出好多的全局变量，给全局变量起名字的问题也回来了。聪明的工程师们很快发现了，这种传递有着很规律的行为，于是把这些行为封装起来，做成库。这种手段叫做“闭包”，block的又一个名字。</p>

<p>把外面的对象，包在匿名函数中，封装起来，以备不时之需。OC利用编译器，在静态检查的时候，把用到的外部变量，都封装到block中。</p>

<p>这使得匿名函数，有了新的活力。在大量的尝试后，发现这简直就是一种神奇，闭包不单使得你的逻辑更加的紧凑，还使得开发变得越来越有趣。nodejs尝试用大量的闭包铸成了一种单线程异步的神奇的库。ReactiveCocoa也用block改变了大家开发iOS的思路。</p>

<p>有了block，我们可以更好的把变化抽取出来，可以更专注的实现逻辑，将异步的，碎片化的需求，快速的整合到一起。相比这些优点，block稍许复杂的语法，和一些可能出现的问题，是可以被原谅的。swift中，我们看到更多的闭包，可以看出block的写法对于开发有着多么深远的影响。</p>

<p>此篇只是一个引子，block有很多需要学习的地方，用好容易，用得精巧，还需要大家更多的开阔思维。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[聊一聊RAC]]></title>
    <link href="http://williamzang.com/blog/2014/08/20/talk-about-rac/"/>
    <updated>2014-08-20T11:17:32+08:00</updated>
    <id>http://williamzang.com/blog/2014/08/20/talk-about-rac</id>
    <content type="html"><![CDATA[<p>今天来聊一聊RAC，这个在Github上很火热的开源框架，相信很多关注iOS前沿开发的人都或多或少的知道。</p>

<p>关于RAC的介绍和一些概念，我这里就不再啰嗦了，大家可以看   <a href="http://limboy.me/about.html">limboy</a>的几篇关于RAC的介绍，很不错。</p>

<blockquote><p><a href="http://limboy.me/ios/2013/06/19/frp-reactivecocoa.html">ReactiveCocoa与Functional Reactive Programming</a><br/>
<a href="http://limboy.me/ios/2013/12/27/reactivecocoa-2.html">说说ReactiveCocoa 2</a><br/>
<a href="http://limboy.me/ios/2014/01/05/ios-rest-client-implementation.html">基于AFNetworking2.0和ReactiveCocoa2.1的iOS REST Client</a><br/>
<a href="http://limboy.me/tech/2014/06/06/deep-into-reactivecocoa2.html">ReactiveCocoa2实战</a></p></blockquote>

<p>此外还有Cocoachina的一系列教程<a href="http://www.cocoachina.com/cms/plus/view.php?aid=8905">Reactive Cocoa详解</a></p>

<p>写Blog，在我看来和开发一样，也要讲究重用，引用列位的信息即可，何必黏贴和表达类似的观点。这里我也仅说一下我自己的理解和看法。</p>

<p>相信很多人都尝试过RAC用到一些小的DEMO或者项目中的一个小部分然后就浅尝辄止了。为什么呢？我觉得主要在于，RAC实际推行的一种新的概念大家还没有习惯，那就是函数响应式编程FRP。<a href="https://github.com/staltz">staltz</a>在一个Gist上倒是给了一个比较全面的解释<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">The introduction to Reactive Programming you&rsquo;ve been missing</a>，可惜是英文的。</p>

<p>这种FRP的核心就在于数据流，FRP把整个的程序认为是数据流的转换，既不是过程、也不是对象。一个系统先产生信号，转换信号，然后业务和界面再接收和响应信号的变化。所以，这是一个新的概念。如果使用别的概念套用，自然用起来就没那么顺手了。那么我们来看看，这样做的好处是什么呢？</p>

<ul>
<li>统一的流处理模式，使得不同的组件可以很好的结合起来，例如iOS的<code>UserDefault</code>、<code>NSNotificationCenter</code>、<code>KVO</code>这些，在RAC库下面，都是相同的封装，这样就使得上层的业务逻辑实现了<strong>大同</strong>，进而一切的信号转换合并都可以有效的结合在一起。</li>
<li>处理异步，很多时候，我们对于异步再同步是比较头大的。而RAC中，一个信号的终止，是不局限在一个函数中的。这样我们可以把不同线程、不同时期的状态绑到一个信号上，使得使用者达到一种内聚。和这种内聚，在转换和迭代的过程中是很必要的。</li>
<li>统一的错误处理，从古老的C时代的<code>int DoSomeThine(int input1, int *output1)</code>这种以返回值返回错误，到后来<code>SetErrorStatus(int ErrorCode, const char *message)</code>的线程栈内全局报错机制，还有现在try-catch机制，都有一个很要命的问题，就是错误处理，或者是可以被忽略，或者是让开发变得很烦恼。Java的try-catch机制，相信Java的开发者们一定深有感触。而RAC把错误变得简单了，它对于错误的处理，会随着变化一起传递到顶层，既不会忘记，也不用在中间环节中手动传递来传递去。</li>
<li>逻辑的拆分，在FRP中，逻辑变得相对独立，通常是一个模块，根据一定的变化产生一个信号，亦或是一个模块，根据一个传入的信号，产生一定的转换。这就使得，我们可以只返回我们的直接结果，后期的加工和变更是分离的。对于上层模块，也只关注信号的类型，不关注处于那个线程还是何种手法。</li>
</ul>


<p>总而言之，RAC给与我们以数据的变化作为出发点，界面与之响应的一套框架。详细的一些技巧，我会在后续的blog中为大家慢慢介绍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[介绍一下开源项目FastAnimationWithPOP]]></title>
    <link href="http://williamzang.com/blog/2014/07/23/jie-shao-yi-xia-kai-yuan-xiang-mu-fastanimationwithpop/"/>
    <updated>2014-07-23T16:07:04+08:00</updated>
    <id>http://williamzang.com/blog/2014/07/23/jie-shao-yi-xia-kai-yuan-xiang-mu-fastanimationwithpop</id>
    <content type="html"><![CDATA[<p>这是一个很简单的动画框架，基于Facebook的POP库。使用它你就可以在故事版中以0行代码的代价来添加动画了。</p>

<p>Github上地址是 <a href="https://github.com/WilliamZang/FastAnimationWithPOP">这里</a>.</p>

<p>你可以从<a href="https://github.com/WilliamZang/FastAnimationWithPopDemo">这里</a>下载DEMO查看效果.</p>

<p><strong>如果你觉得不错，欢迎在到<a href="https://github.com/WilliamZang/FastAnimationWithPOP">这里</a>点个赞，方便让更多人注意到它</strong></p>

<p><img src="https://raw.githubusercontent.com/WilliamZang/FastAnimationWithPOP/master/Docs/demo.gif" alt="Demo" /></p>

<h2>功能</h2>

<ul>
<li>使用属性来添加一个动画到任意的View。</li>
<li>在nib或者故事版唤醒时自动执行动画。</li>
<li>也可以随时手动执行动画。</li>
<li>控制动画的细节。</li>
<li>给control绑定一些动画，例如按下松开等状态。</li>
<li>轻松的扩展新的动画，只需要实现<code>FastAnimationProtocol</code>、<code>ControlFastAnimationProtocol</code> 和 <code>FastAnimationReverseProtocol</code>这几个协议.</li>
</ul>


<h2>环境要求</h2>

<p>iOS SDK: iOS 6.0+</p>

<p>XCode版本: 5.0+</p>

<h2>如何安装</h2>

<p>最好的办法是使用<a href="http://cocoadocs.org">CocoaPods</a>:</p>

<ol>
<li><p>添加这行到你的<code>podfile</code>文件 <code>pod 'FastAnimation'</code></p></li>
<li><p>安装更新 <code>pod install</code></p></li>
</ol>


<p>如果想要尝试最新的版本，你可以添加这个<code>pod 'FastAnimation', :head</code>.</p>

<h2>使用指导</h2>

<h3>1. 在故事板里使用</h3>

<p>你可以通过设置用户自定义运行时属性(user defined runtime attributes)给View添加一个动画。</p>

<p><img src="https://raw.githubusercontent.com/WilliamZang/FastAnimationWithPOP/master/Docs/stroyBoard1.png" alt="StroyBoard1" /></p>

<p><img src="https://raw.githubusercontent.com/WilliamZang/FastAnimationWithPOP/master/Docs/stroyBoard2.png" alt="StroyBoard2" /></p>

<p>下面是一些属性的含义：</p>

<h4>UIView的属性</h4>

<ul>
<li><p>animationType</p>

<p>  通过这个属性来指定动画的类型，可以是完整的类名，也可以省略<code>FAAnimation</code>前缀.</p></li>
<li><p>delay</p>

<p>  执行动画的延时，以秒为单位。</p></li>
<li><p>animationParams</p>

<p>  这个是各个动画的灵活参数，你可以从动画类的头文件中找到信息，例如下面：</p></li>
</ul>


<p>&#8220;`objective-c</p>

<h1>define kSpringBounciness   (@&ldquo;animationParams.springBounciness&rdquo;)</h1>

<h1>define kSpringSpeed        (@&ldquo;animationParams.springSpeed&rdquo;)</h1>

<h1>define kDynamicsTension    (@&ldquo;animationParams.dynamicsTension&rdquo;)</h1>

<h1>define kDynamicsFriction   (@&ldquo;animationParams.dynamicsFriction&rdquo;)</h1>

<h1>define kDynamicsMass       (@&ldquo;animationParams.dynamicsMass&rdquo;)</h1>

<p>&#8220;`</p>

<ul>
<li><p>startAnimationWhenAwakeFromNib</p>

<p>  定义是否需要在故事板唤醒的时候就执行动画，默认是<code>YES</code>。</p></li>
</ul>


<h4>UIControl的属性</h4>

<ul>
<li><p>bindingAnimationType</p>

<p>  通过这个属性来指定控件动画的类型，可以是完整的类名，也可以省略<code>FAAnimation</code>前缀.</p></li>
</ul>


<h3>2. 代码写View的应用</h3>

<p>在代码写View中使用FastAnimation同样方便。</p>

<p>你可以设置动画类型等属性，然后执行<code>- (void)startFAAnimation</code>即可。就像这样：</p>

<p><code>objective-c
UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
view.backgroundColor = [UIColor redColor];
view.animationType = @"Shake";
view.animationParams[@"velocity"] = @-7000;
// You can also set params like this
// [view setValue:@-7000 forKeyPath:kShakeVelocity];
[view startFAAnimation];
</code></p>

<p>还有这些扩展的用法：</p>

<p><code>objective-c
// In UIView instance.
- (void)startFAAnimation;
- (void)reverseFAAnimation;
// In UIControl instance.
- (void)bindingFAAnimation;
- (void)unbindingFAAnimation;
</code></p>

<h3>3. 定义一个新的动画扩展</h3>

<p>轻松的扩展新的动画，只需要实现<code>FastAnimationProtocol</code>、<code>ControlFastAnimationProtocol</code> 和 <code>FastAnimationReverseProtocol</code>这几个协议.</p>

<p>就像这样：</p>

<p>&#8220;`objective-c
// new_animation.h
@interface FAAnimationNewAnimation : NSObject&lt;FastAnimationProtocol,
FastAnimationReverseProtocol> // Maybe only FastAnimationProtocol</p>

<p>@end
// new_animation.m
@implementation FAAnimationBounceRight</p>

<ul>
<li><p>(void)performAnimation:(UIView *)view
{
  // some thing you like.
}</p></li>
<li><p>(void)stopAnimation:(UIView *)view
{
  // some thing you like.
}</p></li>
<li><p>(void)reverseAnimation:(UIView *)view
{
   // some thing you like.
}</p></li>
<li><p>(void)stopReverse:(UIView *)view
{
   // some thing you like.
}
@end</p></li>
</ul>


<p>&#8220;`</p>

<h3>4. 一些控制动画的操作</h3>

<ul>
<li>停止动画：</li>
</ul>


<p>如果想要手动体制，使用下面的方法：</p>

<p><code>objective-c
- (void)stopFAAnimation;
- (void)stopReverseFAAnimation;
</code></p>

<ul>
<li>嵌套动画：</li>
</ul>


<p>使用如下方法处理嵌套：</p>

<p><code>objective-c
- (void)startFAAnimationNested;
- (void)stopFAAnimationNested;
- (void)reverseFAAnimationNested;
- (void)stopReverseFAAnimationNested;
</code></p>

<h3>目前已经拥有的动画:</h3>

<ul>
<li>反弹动画（4方向）: <code>BounceLeft</code>,<code>BounceRight</code>,<code>BounceUp</code>,<code>BounceDown</code></li>
<li>放大动画（2方向）：<code>ZoomInX</code>,<code>ZoomInY</code></li>
<li>颤动动画</li>
<li>组动画</li>
<li>放大动画</li>
<li>Button的放大效果绑定</li>
<li><strong>更多的动画等着大家的贡献哟！</strong></li>
</ul>


<h2>下一步要做的事</h2>

<ul>
<li>把DEMO和库项目和到同一个Workspace里。</li>
<li>制作更多更好看的DEMO。</li>
<li>假如便捷的转场动画，目前先设法支持iOS7+</li>
<li>确保所有的功能都含有单元测试。</li>
<li>更多更好的动画。</li>
<li>把核心部分和效果部分分离，效果按照iOS5 6 7+来打成不同的包.</li>
<li>支持Swift写扩展.</li>
</ul>

]]></content>
  </entry>
  
</feed>
