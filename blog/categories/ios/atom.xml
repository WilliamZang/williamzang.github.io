<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 臧成威的博客]]></title>
  <link href="http://williamzang.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://williamzang.com/"/>
  <updated>2015-08-18T14:03:42+08:00</updated>
  <id>http://williamzang.com/</id>
  <author>
    <name><![CDATA[臧成威]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[细说ReactiveCocoa的冷信号与热信号（二）]]></title>
    <link href="http://williamzang.com/blog/2015/08/18/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-2/"/>
    <updated>2015-08-18T13:51:28+08:00</updated>
    <id>http://williamzang.com/blog/2015/08/18/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-2</id>
    <content type="html"><![CDATA[<h2>为什么要区分冷信号与热信号</h2>

<p>也许你看到前一章节的时候就有疑问，为什么RAC要搞如此复杂的一个概念，直接搞成一种信号不就好了么？要解释这个问题需要绕一些弯路。（前方可能比较难懂，如果不能很好理解，请自行查阅各类文档。）</p>

<p>最前面提到了RAC是一套基于Cocoa的FRP框架，那就来说说FRP，FRP全写是Functional Reactive Programming，中文译作函数响应式编程，是RP（Reactive Programm，响应式编程）的FP（Functional Programming，函数式编程）实现。说起来很拗口。太多的细节不多讨论，我们先关注下它是FP的情况。</p>

<p>FP有几个很重要的概念是和我们的主题相关的：</p>

<p><a href="https://en.wikipedia.org/wiki/Functional_programming#Pure_functions">纯函数</a>是指一个函数或者一个表达式不存在任何的<a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">副作用</a>，就如同数学中的函数：</p>

<blockquote><p>f(x) = 5x + 1</p></blockquote>

<p>这个函数在调用的过程中产生除了返回值以外的任何作用，也不受任何外界因素的影响。那么副作用都有哪些呢？我来列举以下几个情况：</p>

<ul>
<li>函数的处理过程中，修改了外部的变量，例如全局变量。一个特殊点的例子，就是如果把OC的一个方法看做一个函数，所有的成员变量的赋值都是对外部变量的修改。是的，从FP的角度看OOP是充满副作用的。</li>
<li>函数的处理过程中，触发了一些额外的动作，例如发送的全局的一个Notification，在console里面输出的结果，保存了文件，触发了网络，更新的屏幕等。</li>
<li>函数的处理过程中，受到外部变量的影响，例如全局变量，方法里面用到的成员变量。注意block中捕获的外部变量也算副作用。</li>
<li>函数的处理过程中，受到线程锁的影响算副作用。</li>
</ul>


<p>由此我们可以看出，在目前的iOS编程中，我们是很难的摆脱副作用的。或者换一种说法，我们iOS编程的目的其实是副作用。（基于用户触摸的外界因素，最终反馈到网络变化和屏幕变化上。）</p>

<p>接下来我们来分析下副作用与冷热信号的关系。既然iOS编程中少不了副作用，那么RAC在实际的使用中也不可避免的接触副作用，下面我列举个业务场景，来看下冷信号中副作用的坑：</p>

<pre><code class="objective-c">
    self.sessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:@"http://api.xxxx.com"]];

    self.sessionManager.requestSerializer = [AFJSONRequestSerializer serializer];
    self.sessionManager.responseSerializer = [AFJSONResponseSerializer serializer];

    @weakify(self)
    RACSignal *fetchData = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        @strongify(self)
        NSURLSessionDataTask *task = [self.sessionManager GET:@"fetchData" parameters:@{@"someParameter": @"someValue"} success:^(NSURLSessionDataTask *task, id responseObject) {
            [subscriber sendNext:responseObject];
            [subscriber sendCompleted];
        } failure:^(NSURLSessionDataTask *task, NSError *error) {
            [subscriber sendError:error];
        }];
        return [RACDisposable disposableWithBlock:^{
            if (task.state != NSURLSessionTaskStateCompleted) {
                [task cancel];
            }
        }];
    }];

    RACSignal *title = [fetchData flattenMap:^RACSignal *(NSDictionary *value) {
        if ([value[@"title"] isKindOfClass:[NSString class]]) {
            return [RACSignal return:value[@"title"]];
        } else {
            return [RACSignal error:[NSError errorWithDomain:@"some error" code:400 userInfo:@{@"originData": value}]];
        }
    }];

    RACSignal *desc = [fetchData flattenMap:^RACSignal *(NSDictionary *value) {
        if ([value[@"desc"] isKindOfClass:[NSString class]]) {
            return [RACSignal return:value[@"desc"]];
        } else {
            return [RACSignal error:[NSError errorWithDomain:@"some error" code:400 userInfo:@{@"originData": value}]];
        }
    }];

    RACSignal *renderedDesc = [desc flattenMap:^RACStream *(NSString *value) {
        NSError *error = nil;
        RenderManager *renderManager = [[RenderManager alloc] init];
        NSAttributedString *rendered = [renderManager renderText:value error:&amp;error];
        if (error) {
            return [RACSignal error:error];
        } else {
            return [RACSignal return:rendered];
        }
    }];

    RAC(self.someLablel, text) = [[title catchTo:[RACSignal return:@"Error"]]  startWith:@"Loading..."];
    RAC(self.originTextView, text) = [[desc catchTo:[RACSignal return:@"Error"]] startWith:@"Loading..."];
    RAC(self.renderedTextView, attributedText) = [[renderedDesc catchTo:[RACSignal return:[[NSAttributedString alloc] initWithString:@"Error"]]] startWith:[[NSAttributedString alloc] initWithString:@"Loading..."]];

    [[RACSignal merge:@[title, desc, renderedDesc]] subscribeError:^(NSError *error) {
        UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"Error" message:error.domain delegate:nil cancelButtonTitle:@"OK" otherButtonTitles:nil];
        [alertView show];
    }];
</code></pre>

<p>不晓得大家有没有被这么一大段的代码吓到，我想要表达的是，在真正的工程中，我们的业务逻辑是很复杂的，而一些坑就隐藏在如此看似复杂但是又很合理的代码之下。所以我尽量模拟了一些需求，使得代码看起来更丰富，下面我们还是来仔细看下这段代码的逻辑吧：</p>

<ol>
<li>创建了一个<code>AFHTTPSessionManager</code>用来做网络接口的数据获取。</li>
<li>创建了一个名为<code>fetchData</code>的信号来通过网络获取信息。</li>
<li>创建一个名为<code>title</code>的信号从获取的<code>data</code>中取得<code>title</code>字段，如果没有该字段则反馈一个错误。</li>
<li>创建一个名为<code>desc</code>的信号从获取的<code>data</code>中取得<code>desc</code>字段，如果没有该字段则反馈一个错误。</li>
<li>针对<code>desc</code>这个信号做一个渲染，得到一个名为<code>renderedDesc</code>的新信号，该信号会在渲染失败的时候反馈一个错误。</li>
<li>把<code>title</code>信号所有的错误转换为字符串<code>@"Error"</code>并且在没有获取值之前以字符串<code>@"Loading..."</code>占位，之后与<code>self.someLablel</code>的<code>text</code>属性绑定。</li>
<li>把<code>desc</code>信号所有的错误转换为字符串<code>@"Error"</code>并且在没有获取值之前以字符串<code>@"Loading..."</code>占位，之后与<code>self.originTextView</code>的<code>text</code>属性绑定。</li>
<li>把<code>renderedDesc</code>信号所有的错误转换为属性字符串<code>@"Error"</code>并且在没有获取值之前以属性字符串<code>@"Loading..."</code>占位，之后与<code>self.renderedTextView</code>的<code>text</code>属性绑定。</li>
<li>把<code>title</code>、<code>desc</code>、<code>renderedDesc</code>这三个信号的任何错误订阅，并且弹出<code>UIAlertView</code>。</li>
</ol>


<p>看到这里我相信很多熟悉RAC的同学应该是对这些代码表示认同的，它也体现了RAC的一些优势例如良好的错误处理和各种链式处理。但是很遗憾的告诉大家这段代码是有很严重的错误的。</p>

<p>如果你去尝试运行这段代码，并且打开Charles查看，你会惊奇的发现，这个网络请求发送了6次。没错，是6次请求。我们也可以想象到类似的代码在其他副作用的问题，重新刷新了6次屏幕，写入6次文件，发了6个全局通知。</p>

<p>下面来分析下，为什么是6次网络请求呢？首先根据上面的知识，我们可以推断出名为<code>fetchData</code>信号是一个冷信号。那么这个信号在订阅的时候就会执行里面的过程。那这个信号是在什么时候被订阅了呢？仔细回看了代码，我们发现并没有订阅这个信号，只是调用这个信号的<code>flattenMap</code>产生了两个新的信号。</p>

<p><strong>这里有一个很重要的概念，就是任何的信号转换即是对原有的信号进行订阅从而产生新的信号。</strong>我们可以写出flattenMap的伪代码如下：</p>

<pre><code class="objective-c">
- (instancetype)flattenMap_:(RACStream * (^)(id value))block {
{
    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
       return [self subscribeNext:^(id x) {
           RACSignal *signal = (RACSignal *)block(x);
           [signal subscribeNext:^(id x) {
               [subscriber sendNext:x];
           } error:^(NSError *error) {
               [subscriber sendError:error];
           } completed:^{
               [subscriber sendCompleted];
           }];
       } error:^(NSError *error) {
           [subscriber sendError:error];
       } completed:^{
           [subscriber sendCompleted];
       }];
    }];
}
</code></pre>

<p>除了没有高度复用和缺少一些disposable的处理以外，上述代码可以大致的给我们<code>flattenMap</code>的直观处理，我们可以看到其实是在调用这个方法的时候，生成了一个新的信号，在这个新的信号的执行过程中对<code>self</code>进行的了<strong>订阅</strong>。我们还需要注意一个细节，就是这个返回信号在未来订阅的时候，才会间接的订阅了<code>self</code>。后续的<code>startWith</code>、<code>catchTo</code>等都可以这样理解。</p>

<p>回到我们的问题，那就是说，在<code>fetchData</code>被<code>flattenMap</code>之后，它就会因为名为<code>title</code>和<code>desc</code>信号的订阅而订阅。而后续我们对<code>desc</code>也进行了<code>flattenMap</code>得到了<code>renderedDesc</code>，那也说明了未来<code>renderedDesc</code>被订阅的时候，<code>fetchData</code>也会被间接订阅。所以我们解释了在后续我们用RAC宏进行绑定的时候，引发的<strong>3次</strong><code>fetchData</code>的订阅。由于<code>fetchData</code>是冷信号，所以3次订阅意味着它的过程被执行了3次，也就是网络的3次请求。</p>

<p>另外的3次订阅来自<code>RACSignal</code>类的<code>merge</code>方法。根据上述的描述，我们也可以猜测<code>merge</code>方法也一定是创建了一个新的信号，在这个信号被订阅的时候，把它包含的所有信号订阅。所以我们又得到了额外的3次网络请求。</p>

<p>由此我们可以深刻的看到不熟悉冷热信号对业务造成的影响。我们可以想象对用户流量的影响，对服务器负载的影响，对统计的影响，如果这是一个点赞的接口，会不会造成多次点赞？后果是不堪的。而着一些都可以通过把<code>fetchData</code>转换为热信号来解决。</p>

<p>接下来也许你会问，如果我的整个计算过程中都没有副作用，是否就不会有这个问题，答案是肯定的，试想下刚才那段代码如果没有网络请求，换成一些标准化的计算会怎样。可以肯定的是我们不会出现bug，但是不要忽视的就是其中的运算我们执行了多次。刚才在介绍纯函数的时候，还有一个概念就是<a href="https://en.wikipedia.org/wiki/Referential_transparency_(computer_science)">引用透明</a>，我们可以在纯函数式语言（例如<a href="https://www.haskell.org">Haskell</a>）上进行一定的优化，<strong>也就是说纯函数的调用在相同参数下的返回值第二次不需要计算</strong>，所以在纯函数式语言里面的FRP并没有冷信号的担忧。然而Objective-C语言中并未对纯函数进行优化。所以拥有大规模运算的冷信号对性能也是有一定影响的。</p>

<p>所以如果我们想更好的掌握RAC这个框架，区分冷信号与热信号是十分重要的。下一部分我会讲述如何正确理解冷信号与热信号。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[细说ReactiveCocoa的冷信号与热信号（一）]]></title>
    <link href="http://williamzang.com/blog/2015/08/18/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-1/"/>
    <updated>2015-08-18T12:21:28+08:00</updated>
    <id>http://williamzang.com/blog/2015/08/18/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-1</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p><a href="http://www.github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>（简称RAC）是一套基于Cocoa的FRP框架，在我们美团客户端中，我们大量使用了这个框架。而在使用的过程中我们发现，冷信号与热信号的概念很容易混淆并且容易造成一定的问题，相信各位在使用的过程中也可能遇到此类问题。所以我在这里与大家讨论下RAC中冷信号与热信号的相关知识点，希望可以加深大家对冷热信号的理解。</p>

<p>p.s. 以下代码和示例基于<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/releases/tag/v2.5">ReactiveCocoa v2.5</a></p>

<h2>什么是冷信号与热信号</h2>

<p>冷热信号的概念源于C#的MVVM框架<a href="https://msdn.microsoft.com/en-us/library/hh242985.aspx">Reactive Extensions</a>中的Hot Observables和Cold Observables:</p>

<blockquote><p>Hot Observables和Cold Observables的区别：</p>

<ol>
<li><p>Hot Observables是主动的，尽管你并没有订阅事件，但是它会时刻推送，就像鼠标移动；而Cold Observables是被动的，只有当你订阅的时候，它才会发布消息。</p></li>
<li><p>Hot Observables可以有多个订阅者，是一对多，集合可以与订阅者共享信息；而Cold Observables只能一对一，当有不同的订阅者，消息是重新完整发送。</p></li>
</ol>
</blockquote>

<p>这里面的Observables可以理解为RACSignal。为了加深理解，请大家关注这样的几组代码：</p>

<pre><code class="objective-c">    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        [subscriber sendNext:@1];
        [subscriber sendNext:@2];
        [subscriber sendNext:@3];
        [subscriber sendCompleted];
        return nil;
    }];
    NSLog(@"Signal was created.");
    [[RACScheduler mainThreadScheduler] afterDelay:0.1 schedule:^{
        [signal subscribeNext:^(id x) {
            NSLog(@"Subscriber 1 recveive: %@", x);
        }];
    }];

    [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{
        [signal subscribeNext:^(id x) {
            NSLog(@"Subscriber 2 recveive: %@", x);
        }];
    }];    
</code></pre>

<p>以上简单的创建了一个信号，并且依次发送@1，@2，@3作为值。下面分别有两个订阅者在不同的时间段进行了订阅，运行的结果如下：</p>

<pre><code>2015-08-11 18:33:21.681 RACDemos[6505:1125196] Signal was created.
2015-08-11 18:33:21.793 RACDemos[6505:1125196] Subscriber 1 recveive: 1
2015-08-11 18:33:21.793 RACDemos[6505:1125196] Subscriber 1 recveive: 2
2015-08-11 18:33:21.793 RACDemos[6505:1125196] Subscriber 1 recveive: 3
2015-08-11 18:33:22.683 RACDemos[6505:1125196] Subscriber 2 recveive: 1
2015-08-11 18:33:22.683 RACDemos[6505:1125196] Subscriber 2 recveive: 2
2015-08-11 18:33:22.683 RACDemos[6505:1125196] Subscriber 2 recveive: 3
</code></pre>

<p>我们可以看到，信号在18:33:21.681时被创建，18:33:21.793依次接到1、2、3三个值，而在18:33:22.683再依次接到1、2、3三个值。说明了变量名为<code>signal</code>的这个信号，在两个不同时间段的订阅过程中，分别完整的发送了所有的消息。</p>

<p>我们再对这段代码进行一个小的改动：</p>

<pre><code class="objective-c">    RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{
            [subscriber sendNext:@1];
        }];

        [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^{
            [subscriber sendNext:@2];
        }];

        [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^{
            [subscriber sendNext:@3];
        }];

        [[RACScheduler mainThreadScheduler] afterDelay:4 schedule:^{
            [subscriber sendCompleted];
        }];
        return nil;
    }] publish];
    [connection connect];
    RACSignal *signal = connection.signal;

    NSLog(@"Signal was created.");
    [[RACScheduler mainThreadScheduler] afterDelay:1.1 schedule:^{
        [signal subscribeNext:^(id x) {
            NSLog(@"Subscriber 1 recveive: %@", x);
        }];
    }];

    [[RACScheduler mainThreadScheduler] afterDelay:2.1 schedule:^{
        [signal subscribeNext:^(id x) {
            NSLog(@"Subscriber 2 recveive: %@", x);
        }];
    }];
</code></pre>

<p>稍微有些复杂，我们来一一分析下：</p>

<ul>
<li>创建了一个信号，在1秒、2秒、3秒分别发送1、2、3这三个值，4秒发送结束信号。</li>
<li>对这个信号调用publish方法得到一个RACMulticastConnection。</li>
<li>将connection进行连接操作。</li>
<li>获得connection的信号。</li>
<li>分别在0.1秒和2秒订阅获得的信号。</li>
</ul>


<p>抛开RACMulticastConnection是个什么东东，我们先来看下结果：</p>

<pre><code>2015-08-12 11:07:49.943 RACDemos[9418:1186344] Signal was created.
2015-08-12 11:07:52.088 RACDemos[9418:1186344] Subscriber 1 recveive: 2
2015-08-12 11:07:53.044 RACDemos[9418:1186344] Subscriber 1 recveive: 3
2015-08-12 11:07:53.044 RACDemos[9418:1186344] Subscriber 2 recveive: 3
</code></pre>

<p>首先告诉大家<code>-[RACSignal publish]</code>、<code>- [RACMulticastConnection connect]</code>、<code>- [RACMulticastConnection signal]</code>这几个操作生成了一个热信号。
我们再来关注下输出结果的一些细节：</p>

<ul>
<li>信号在11:07:49.943被创建</li>
<li>11:07:52.088时订阅者1才收到2这个值，说明1这个值没有接收到，时间间隔是2秒多</li>
<li>11:07:53.044时订阅者1和订阅者2同时收到3这个值，时间间隔是3秒多</li>
</ul>


<p>参考一开始的Hot Observables的论述和两段小程序的输出结果，我们可以确定冷热信号的如下特点：</p>

<ul>
<li>一、热信号是主动的，即使你没有订阅事件，它仍然会时刻推送。（如第二个例子，信号在50秒被创建，51秒的时候1这个值就推送出来了，但是当时还没有订阅者。）而冷信号是被动的，只有当你订阅的时候，它才会发送消息。（如第一个例子。）</li>
<li>二、热信号可以有多个订阅者，是一对多，信号可以与订阅者共享信息（如第二个例子，订阅者1和订阅者2是共享的，他们都能在同一时间接收到3这个值。）而冷信号只能一对一，当有不同的订阅者，消息会从新完整发送。（如第一个例子，我们可以观察到两个订阅者没有联系，都是基于各自的订阅时间开始接收消息的。）</li>
</ul>


<p>好的，至此我们知道了什么是冷信号与热信号，了解了它们的特点。下一部分我们来看看为什么要区分冷信号与热信号。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从另一个角度介绍下Block]]></title>
    <link href="http://williamzang.com/blog/2014/09/09/cong-ling-yi-ge-jiao-du-jie-shao-xia-block/"/>
    <updated>2014-09-09T10:27:24+08:00</updated>
    <id>http://williamzang.com/blog/2014/09/09/cong-ling-yi-ge-jiao-du-jie-shao-xia-block</id>
    <content type="html"><![CDATA[<p>群里有个小伙伴问我block的理解，我想网上那么多blog都写过iOS的block的介绍，说明，用法，如果还是不能理解，那就换个角度吧。所以，今天我们来聊一聊Block的前世今生，不谈block如何定义，不谈block有哪些坑，只谈它是怎么来的。</p>

<p>首先block的使用，真的不必多说，想必大家google后也都会用。问题就在于，为什么要有block？有人觉得block方便，到底方便在哪里呢？这一切要从函数指针这个很老的概念谈起了。</p>

<p>在C时代，面向过程一度成为程序开发的主流，在没有对象化的程序设计中，我们难免写出如下的程序：</p>

<pre><code class="c">extern const char *GetMenu0();
extern const char *GetMenu1();
extern const char *GetMenu2();
extern const char *GetMenu3();
extern const char *GetMenu4();
extern const char *GetMenu5();



const char *GetMenuShow(int pos) {
    switch (pos) {
        case 0: return GetMenu0();
        case 1: return GetMenu1();
        case 2: return GetMenu2();
        case 3: return GetMenu3();
        case 4: return GetMenu4();
        case 5: return GetMenu5();
        default:
            return NULL;
    }
}
</code></pre>

<p>随着程序的复杂度提高，这样的程序变得越来越长，这时函数指针可以来帮忙，于是函数就变成了这样：</p>

<pre><code class="c">extern const char *GetMenu0();
extern const char *GetMenu1();
extern const char *GetMenu2();
extern const char *GetMenu3();
extern const char *GetMenu4();
extern const char *GetMenu5();

typedef const char *(*MenuMethodType)();

static MenuMethodType g_methods[] = {
  &amp;GetMenu0,
  &amp;GetMenu1,
  &amp;GetMenu2,
  &amp;GetMenu3,
  &amp;GetMenu4,
  &amp;GetMenu5
};


const char *GetMenuShow(int pos) {
    if (pos &lt; 0 || pos &gt;= (sizeof(g_methods) / sizeof(MenuMethodType))) {
        return NULL;
    }
    return g_methods[pos]();
}
</code></pre>

<p>这种写法也叫做跳转表，好处是以后GetMenu*这种函数的增长可以放到GetMenuShow这个函数外，减少了耦合。函数指针的另一个妙用就是回调函数，这个非常的普遍，也不需要再举例子了。</p>

<p>函数指针给我们带来的新的开发思想，就是行为的变量化，因此，我们可以将不同的行为封装到统一的流程之外，作为可替换的组件。总之，它允许你把可变化的行为，注入到稳定的过程中，我们便获得了更好的扩展，把开发的中心放到变化而不是重复上。</p>

<p>到了OC时代，OC有了一种比函数指针还高效而简单的东西，那就是selector。这个被称为选择器的工具，不仅可以让我们得到函数指针的一切便利，还可以动态的替换其指向的内容。于是我们有了很多<code>addTarget:action:</code>这样的API，使得我们可以把行为注入到已经非常稳定的Cocoa或CocoaTouch框架中。</p>

<p>虽然有了一定的便利，但是程序员是不容易满足的。我们逐渐发现，这种基于action的写法有时很麻烦。主要是以下几点：</p>

<ol>
<li>就是很多时候，你注入的内容可能就一次，搞一个函数或者方法，浪费了不少的时间。</li>
<li>你还要起名字，要知道，Phil Karlton就说过:“在计算机科学领域,有两大难题,如何验证缓存和如何给各种东西命名。”</li>
<li>使得你原本可以在一个函数里实现的逻辑，分散到不同的部分，你难以专注的一次把你的逻辑写完。</li>
</ol>


<p>这时，我们的主角block就来帮助大家了。</p>

<p>其实block还有很多别名，其中一个就是匿名函数。利用block，你可以在一个函数中，写上一小段代码，不用起名字，就可以传递过去。函数指针的用法，几乎都可以用匿名函数来替换。一举解决了碎片化，命名等问题。我们便有了这样的代码：</p>

<pre><code class="objective-c">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
[manager GET:@"http://example.com/resources.json" parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
</code></pre>

<p>贪婪的程序员不仅仅满足于少起个名字和把代码写到一起，一旦程序员们发现，把一个函数写在另一个函数里很爽，就开始频繁的尝试。这时，又发现了几个小问题（以下仅是匿名函数的问题，block解决了这些问题）：</p>

<ol>
<li>匿名函数，到底还是一个函数，这个括号外面世界的变量，是不可以在里面使用的。</li>
<li>由于只能传递一个函数，我们就没有了可操作的对象（即没有了self）。</li>
</ol>


<p>其实这两个是一样的问题，都是因为没有变量的传递。如果可以把self传递下来，第二个问题也解决了。</p>

<p>想要解决这个问题，最简单的方法就是搞到全局域，于是代码就写成了这样：</p>

<pre><code class="objective-c">static int g_sum = 0;

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    g_sum = 0;
    [@[@1, @2, @3] enumerateObjectsUsingBlock:^(NSNumber *obj, NSUInteger idx, BOOL *stop) {
        int val = [obj intValue];
        g_sum += val;
    }];
    NSLog(@"sum = %d", g_sum);

    // Override point for customization after application launch.
    return YES;
}
</code></pre>

<p>把想要在匿名函数中的部分先存到全局变量，然后再到匿名函数中取出来。我们原本想解决的碎片化问题，又回来了。这样情况下，我们不得不搞出好多的全局变量，给全局变量起名字的问题也回来了。聪明的工程师们很快发现了，这种传递有着很规律的行为，于是把这些行为封装起来，做成库。这种手段叫做“闭包”，block的又一个名字。</p>

<p>把外面的对象，包在匿名函数中，封装起来，以备不时之需。OC利用编译器，在静态检查的时候，把用到的外部变量，都封装到block中。</p>

<p>这使得匿名函数，有了新的活力。在大量的尝试后，发现这简直就是一种神奇，闭包不单使得你的逻辑更加的紧凑，还使得开发变得越来越有趣。nodejs尝试用大量的闭包铸成了一种单线程异步的神奇的库。ReactiveCocoa也用block改变了大家开发iOS的思路。</p>

<p>有了block，我们可以更好的把变化抽取出来，可以更专注的实现逻辑，将异步的，碎片化的需求，快速的整合到一起。相比这些优点，block稍许复杂的语法，和一些可能出现的问题，是可以被原谅的。swift中，我们看到更多的闭包，可以看出block的写法对于开发有着多么深远的影响。</p>

<p>此篇只是一个引子，block有很多需要学习的地方，用好容易，用得精巧，还需要大家更多的开阔思维。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[聊一聊RAC]]></title>
    <link href="http://williamzang.com/blog/2014/08/20/talk-about-rac/"/>
    <updated>2014-08-20T11:17:32+08:00</updated>
    <id>http://williamzang.com/blog/2014/08/20/talk-about-rac</id>
    <content type="html"><![CDATA[<p>今天来聊一聊RAC，这个在Github上很火热的开源框架，相信很多关注iOS前沿开发的人都或多或少的知道。</p>

<p>关于RAC的介绍和一些概念，我这里就不再啰嗦了，大家可以看   <a href="http://limboy.me/about.html">limboy</a>的几篇关于RAC的介绍，很不错。</p>

<blockquote><p><a href="http://limboy.me/ios/2013/06/19/frp-reactivecocoa.html">ReactiveCocoa与Functional Reactive Programming</a><br/>
<a href="http://limboy.me/ios/2013/12/27/reactivecocoa-2.html">说说ReactiveCocoa 2</a><br/>
<a href="http://limboy.me/ios/2014/01/05/ios-rest-client-implementation.html">基于AFNetworking2.0和ReactiveCocoa2.1的iOS REST Client</a><br/>
<a href="http://limboy.me/tech/2014/06/06/deep-into-reactivecocoa2.html">ReactiveCocoa2实战</a></p></blockquote>

<p>此外还有Cocoachina的一系列教程<a href="http://www.cocoachina.com/cms/plus/view.php?aid=8905">Reactive Cocoa详解</a></p>

<p>写Blog，在我看来和开发一样，也要讲究重用，引用列位的信息即可，何必黏贴和表达类似的观点。这里我也仅说一下我自己的理解和看法。</p>

<p>相信很多人都尝试过RAC用到一些小的DEMO或者项目中的一个小部分然后就浅尝辄止了。为什么呢？我觉得主要在于，RAC实际推行的一种新的概念大家还没有习惯，那就是函数响应式编程FRP。<a href="https://github.com/staltz">staltz</a>在一个Gist上倒是给了一个比较全面的解释<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">The introduction to Reactive Programming you&rsquo;ve been missing</a>，可惜是英文的。</p>

<p>这种FRP的核心就在于数据流，FRP把整个的程序认为是数据流的转换，既不是过程、也不是对象。一个系统先产生信号，转换信号，然后业务和界面再接收和响应信号的变化。所以，这是一个新的概念。如果使用别的概念套用，自然用起来就没那么顺手了。那么我们来看看，这样做的好处是什么呢？</p>

<ul>
<li>统一的流处理模式，使得不同的组件可以很好的结合起来，例如iOS的<code>UserDefault</code>、<code>NSNotificationCenter</code>、<code>KVO</code>这些，在RAC库下面，都是相同的封装，这样就使得上层的业务逻辑实现了<strong>大同</strong>，进而一切的信号转换合并都可以有效的结合在一起。</li>
<li>处理异步，很多时候，我们对于异步再同步是比较头大的。而RAC中，一个信号的终止，是不局限在一个函数中的。这样我们可以把不同线程、不同时期的状态绑到一个信号上，使得使用者达到一种内聚。和这种内聚，在转换和迭代的过程中是很必要的。</li>
<li>统一的错误处理，从古老的C时代的<code>int DoSomeThine(int input1, int *output1)</code>这种以返回值返回错误，到后来<code>SetErrorStatus(int ErrorCode, const char *message)</code>的线程栈内全局报错机制，还有现在try-catch机制，都有一个很要命的问题，就是错误处理，或者是可以被忽略，或者是让开发变得很烦恼。Java的try-catch机制，相信Java的开发者们一定深有感触。而RAC把错误变得简单了，它对于错误的处理，会随着变化一起传递到顶层，既不会忘记，也不用在中间环节中手动传递来传递去。</li>
<li>逻辑的拆分，在FRP中，逻辑变得相对独立，通常是一个模块，根据一定的变化产生一个信号，亦或是一个模块，根据一个传入的信号，产生一定的转换。这就使得，我们可以只返回我们的直接结果，后期的加工和变更是分离的。对于上层模块，也只关注信号的类型，不关注处于那个线程还是何种手法。</li>
</ul>


<p>总而言之，RAC给与我们以数据的变化作为出发点，界面与之响应的一套框架。详细的一些技巧，我会在后续的blog中为大家慢慢介绍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[介绍一下开源项目FastAnimationWithPOP]]></title>
    <link href="http://williamzang.com/blog/2014/07/23/jie-shao-yi-xia-kai-yuan-xiang-mu-fastanimationwithpop/"/>
    <updated>2014-07-23T16:07:04+08:00</updated>
    <id>http://williamzang.com/blog/2014/07/23/jie-shao-yi-xia-kai-yuan-xiang-mu-fastanimationwithpop</id>
    <content type="html"><![CDATA[<p>这是一个很简单的动画框架，基于Facebook的POP库。使用它你就可以在故事版中以0行代码的代价来添加动画了。</p>

<p>Github上地址是 <a href="https://github.com/WilliamZang/FastAnimationWithPOP">这里</a>.</p>

<p>你可以从<a href="https://github.com/WilliamZang/FastAnimationWithPopDemo">这里</a>下载DEMO查看效果.</p>

<p><strong>如果你觉得不错，欢迎在到<a href="https://github.com/WilliamZang/FastAnimationWithPOP">这里</a>点个赞，方便让更多人注意到它</strong></p>

<p><img src="https://raw.githubusercontent.com/WilliamZang/FastAnimationWithPOP/master/Docs/demo.gif" alt="Demo" /></p>

<h2>功能</h2>

<ul>
<li>使用属性来添加一个动画到任意的View。</li>
<li>在nib或者故事版唤醒时自动执行动画。</li>
<li>也可以随时手动执行动画。</li>
<li>控制动画的细节。</li>
<li>给control绑定一些动画，例如按下松开等状态。</li>
<li>轻松的扩展新的动画，只需要实现<code>FastAnimationProtocol</code>、<code>ControlFastAnimationProtocol</code> 和 <code>FastAnimationReverseProtocol</code>这几个协议.</li>
</ul>


<h2>环境要求</h2>

<p>iOS SDK: iOS 6.0+</p>

<p>XCode版本: 5.0+</p>

<h2>如何安装</h2>

<p>最好的办法是使用<a href="http://cocoadocs.org">CocoaPods</a>:</p>

<ol>
<li><p>添加这行到你的<code>podfile</code>文件 <code>pod 'FastAnimation'</code></p></li>
<li><p>安装更新 <code>pod install</code></p></li>
</ol>


<p>如果想要尝试最新的版本，你可以添加这个<code>pod 'FastAnimation', :head</code>.</p>

<h2>使用指导</h2>

<h3>1. 在故事板里使用</h3>

<p>你可以通过设置用户自定义运行时属性(user defined runtime attributes)给View添加一个动画。</p>

<p><img src="https://raw.githubusercontent.com/WilliamZang/FastAnimationWithPOP/master/Docs/stroyBoard1.png" alt="StroyBoard1" /></p>

<p><img src="https://raw.githubusercontent.com/WilliamZang/FastAnimationWithPOP/master/Docs/stroyBoard2.png" alt="StroyBoard2" /></p>

<p>下面是一些属性的含义：</p>

<h4>UIView的属性</h4>

<ul>
<li><p>animationType</p>

<p>  通过这个属性来指定动画的类型，可以是完整的类名，也可以省略<code>FAAnimation</code>前缀.</p></li>
<li><p>delay</p>

<p>  执行动画的延时，以秒为单位。</p></li>
<li><p>animationParams</p>

<p>  这个是各个动画的灵活参数，你可以从动画类的头文件中找到信息，例如下面：</p></li>
</ul>


<pre><code class="objective-c">#define kSpringBounciness   (@"animationParams.springBounciness")
#define kSpringSpeed        (@"animationParams.springSpeed")
#define kDynamicsTension    (@"animationParams.dynamicsTension")
#define kDynamicsFriction   (@"animationParams.dynamicsFriction")
#define kDynamicsMass       (@"animationParams.dynamicsMass")
</code></pre>

<ul>
<li><p>startAnimationWhenAwakeFromNib</p>

<p>  定义是否需要在故事板唤醒的时候就执行动画，默认是<code>YES</code>。</p></li>
</ul>


<h4>UIControl的属性</h4>

<ul>
<li><p>bindingAnimationType</p>

<p>  通过这个属性来指定控件动画的类型，可以是完整的类名，也可以省略<code>FAAnimation</code>前缀.</p></li>
</ul>


<h3>2. 代码写View的应用</h3>

<p>在代码写View中使用FastAnimation同样方便。</p>

<p>你可以设置动画类型等属性，然后执行<code>- (void)startFAAnimation</code>即可。就像这样：</p>

<pre><code class="objective-c">UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
view.backgroundColor = [UIColor redColor];
view.animationType = @"Shake";
view.animationParams[@"velocity"] = @-7000;
// You can also set params like this
// [view setValue:@-7000 forKeyPath:kShakeVelocity];
[view startFAAnimation];
</code></pre>

<p>还有这些扩展的用法：</p>

<pre><code class="objective-c">// In UIView instance.
- (void)startFAAnimation;
- (void)reverseFAAnimation;
// In UIControl instance.
- (void)bindingFAAnimation;
- (void)unbindingFAAnimation;
</code></pre>

<h3>3. 定义一个新的动画扩展</h3>

<p>轻松的扩展新的动画，只需要实现<code>FastAnimationProtocol</code>、<code>ControlFastAnimationProtocol</code> 和 <code>FastAnimationReverseProtocol</code>这几个协议.</p>

<p>就像这样：</p>

<pre><code class="objective-c">// new_animation.h
@interface FAAnimationNewAnimation : NSObject&lt;FastAnimationProtocol, 
FastAnimationReverseProtocol&gt; // Maybe only FastAnimationProtocol

@end
// new_animation.m
@implementation FAAnimationBounceRight

+ (void)performAnimation:(UIView *)view
{
    // some thing you like.
}

+ (void)stopAnimation:(UIView *)view
{
    // some thing you like.
}

+ (void)reverseAnimation:(UIView *)view
{
     // some thing you like.
}

+ (void)stopReverse:(UIView *)view
{
     // some thing you like.
}
@end
</code></pre>

<h3>4. 一些控制动画的操作</h3>

<ul>
<li>停止动画：</li>
</ul>


<p>如果想要手动体制，使用下面的方法：</p>

<pre><code class="objective-c">- (void)stopFAAnimation;
- (void)stopReverseFAAnimation;
</code></pre>

<ul>
<li>嵌套动画：</li>
</ul>


<p>使用如下方法处理嵌套：</p>

<pre><code class="objective-c">- (void)startFAAnimationNested;
- (void)stopFAAnimationNested;
- (void)reverseFAAnimationNested;
- (void)stopReverseFAAnimationNested;
</code></pre>

<h3>目前已经拥有的动画:</h3>

<ul>
<li>反弹动画（4方向）: <code>BounceLeft</code>,<code>BounceRight</code>,<code>BounceUp</code>,<code>BounceDown</code></li>
<li>放大动画（2方向）：<code>ZoomInX</code>,<code>ZoomInY</code></li>
<li>颤动动画</li>
<li>组动画</li>
<li>放大动画</li>
<li>Button的放大效果绑定</li>
<li><strong>更多的动画等着大家的贡献哟！</strong></li>
</ul>


<h2>下一步要做的事</h2>

<ul>
<li>把DEMO和库项目和到同一个Workspace里。</li>
<li>制作更多更好看的DEMO。</li>
<li>假如便捷的转场动画，目前先设法支持iOS7+</li>
<li>确保所有的功能都含有单元测试。</li>
<li>更多更好的动画。</li>
<li>把核心部分和效果部分分离，效果按照iOS5 6 7+来打成不同的包.</li>
<li>支持Swift写扩展.</li>
</ul>

]]></content>
  </entry>
  
</feed>
