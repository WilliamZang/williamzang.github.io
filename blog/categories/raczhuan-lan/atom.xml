<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rac专栏 | 臧成威的博客]]></title>
  <link href="http://williamzang.com/blog/categories/raczhuan-lan/atom.xml" rel="self"/>
  <link href="http://williamzang.com/"/>
  <updated>2015-08-18T12:29:17+08:00</updated>
  <id>http://williamzang.com/</id>
  <author>
    <name><![CDATA[臧成威]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[细说ReactiveCocoa的冷信号与热信号（一）]]></title>
    <link href="http://williamzang.com/blog/2015/08/18/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-1/"/>
    <updated>2015-08-18T12:21:28+08:00</updated>
    <id>http://williamzang.com/blog/2015/08/18/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-1</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p><a href="http://www.github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>（简称RAC）是一套基于Cocoa的FRP框架，在我们美团客户端中，我们大量使用了这个框架。而在使用的过程中我们发现，冷信号与热信号的概念很容易混淆并且容易造成一定的问题，相信各位在使用的过程中也可能遇到此类问题。所以我在这里与大家讨论下RAC中冷信号与热信号的相关知识点，希望可以加深大家对冷热信号的理解。</p>

<p>p.s. 以下代码和示例基于<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/releases/tag/v2.5">ReactiveCocoa v2.5</a></p>

<h2>什么是冷信号与热信号</h2>

<p>冷热信号的概念源于C#的MVVM框架<a href="https://msdn.microsoft.com/en-us/library/hh242985.aspx">Reactive Extensions</a>中的Hot Observables和Cold Observables:</p>

<blockquote><p>Hot Observables和Cold Observables的区别：</p>

<ol>
<li><p>Hot Observables是主动的，尽管你并没有订阅事件，但是它会时刻推送，就像鼠标移动；而Cold Observables是被动的，只有当你订阅的时候，它才会发布消息。</p></li>
<li><p>Hot Observables可以有多个订阅者，是一对多，集合可以与订阅者共享信息；而Cold Observables只能一对一，当有不同的订阅者，消息是重新完整发送。</p></li>
</ol>
</blockquote>

<p>这里面的Observables可以理解为RACSignal。为了加深理解，请大家关注这样的几组代码：</p>

<pre><code class="objective-c">    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        [subscriber sendNext:@1];
        [subscriber sendNext:@2];
        [subscriber sendNext:@3];
        [subscriber sendCompleted];
        return nil;
    }];
    NSLog(@"Signal was created.");
    [[RACScheduler mainThreadScheduler] afterDelay:0.1 schedule:^{
        [signal subscribeNext:^(id x) {
            NSLog(@"Subscriber 1 recveive: %@", x);
        }];
    }];

    [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{
        [signal subscribeNext:^(id x) {
            NSLog(@"Subscriber 2 recveive: %@", x);
        }];
    }];    
</code></pre>

<p>以上简单的创建了一个信号，并且依次发送@1，@2，@3作为值。下面分别有两个订阅者在不同的时间段进行了订阅，运行的结果如下：</p>

<pre><code>2015-08-11 18:33:21.681 RACDemos[6505:1125196] Signal was created.
2015-08-11 18:33:21.793 RACDemos[6505:1125196] Subscriber 1 recveive: 1
2015-08-11 18:33:21.793 RACDemos[6505:1125196] Subscriber 1 recveive: 2
2015-08-11 18:33:21.793 RACDemos[6505:1125196] Subscriber 1 recveive: 3
2015-08-11 18:33:22.683 RACDemos[6505:1125196] Subscriber 2 recveive: 1
2015-08-11 18:33:22.683 RACDemos[6505:1125196] Subscriber 2 recveive: 2
2015-08-11 18:33:22.683 RACDemos[6505:1125196] Subscriber 2 recveive: 3
</code></pre>

<p>我们可以看到，信号在18:33:21.681时被创建，18:33:21.793依次接到1、2、3三个值，而在18:33:22.683再依次接到1、2、3三个值。说明了变量名为<code>signal</code>的这个信号，在两个不同时间段的订阅过程中，分别完整的发送了所有的消息。</p>

<p>我们再对这段代码进行一个小的改动：</p>

<pre><code class="objective-c">    RACMulticastConnection *connection = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^{
            [subscriber sendNext:@1];
        }];

        [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^{
            [subscriber sendNext:@2];
        }];

        [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^{
            [subscriber sendNext:@3];
        }];

        [[RACScheduler mainThreadScheduler] afterDelay:4 schedule:^{
            [subscriber sendCompleted];
        }];
        return nil;
    }] publish];
    [connection connect];
    RACSignal *signal = connection.signal;

    NSLog(@"Signal was created.");
    [[RACScheduler mainThreadScheduler] afterDelay:1.1 schedule:^{
        [signal subscribeNext:^(id x) {
            NSLog(@"Subscriber 1 recveive: %@", x);
        }];
    }];

    [[RACScheduler mainThreadScheduler] afterDelay:2.1 schedule:^{
        [signal subscribeNext:^(id x) {
            NSLog(@"Subscriber 2 recveive: %@", x);
        }];
    }];
</code></pre>

<p>稍微有些复杂，我们来一一分析下：</p>

<ul>
<li>创建了一个信号，在1秒、2秒、3秒分别发送1、2、3这三个值，4秒发送结束信号。</li>
<li>对这个信号调用publish方法得到一个RACMulticastConnection。</li>
<li>将connection进行连接操作。</li>
<li>获得connection的信号。</li>
<li>分别在0.1秒和2秒订阅获得的信号。</li>
</ul>


<p>抛开RACMulticastConnection是个什么东东，我们先来看下结果：</p>

<pre><code>2015-08-12 11:07:49.943 RACDemos[9418:1186344] Signal was created.
2015-08-12 11:07:52.088 RACDemos[9418:1186344] Subscriber 1 recveive: 2
2015-08-12 11:07:53.044 RACDemos[9418:1186344] Subscriber 1 recveive: 3
2015-08-12 11:07:53.044 RACDemos[9418:1186344] Subscriber 2 recveive: 3
</code></pre>

<p>首先告诉大家<code>-[RACSignal publish]</code>、<code>- [RACMulticastConnection connect]</code>、<code>- [RACMulticastConnection signal]</code>这几个操作生成了一个热信号。
我们再来关注下输出结果的一些细节：</p>

<ul>
<li>信号在11:07:49.943被创建</li>
<li>11:07:52.088时订阅者1才收到2这个值，说明1这个值没有接收到，时间间隔是2秒多</li>
<li>11:07:53.044时订阅者1和订阅者2同时收到3这个值，时间间隔是3秒多</li>
</ul>


<p>参考一开始的Hot Observables的论述和两段小程序的输出结果，我们可以确定冷热信号的如下特点：</p>

<ul>
<li>一、热信号是主动的，即使你没有订阅事件，它仍然会时刻推送。（如第二个例子，信号在50秒被创建，51秒的时候1这个值就推送出来了，但是当时还没有订阅者。）而冷信号是被动的，只有当你订阅的时候，它才会发送消息。（如第一个例子。）</li>
<li>二、热信号可以有多个订阅者，是一对多，信号可以与订阅者共享信息（如第二个例子，订阅者1和订阅者2是共享的，他们都能在同一时间接收到3这个值。）而冷信号只能一对一，当有不同的订阅者，消息会从新完整发送。（如第一个例子，我们可以观察到两个订阅者没有联系，都是基于各自的订阅时间开始接收消息的。）</li>
</ul>


<p>好的，至此我们知道了什么是冷信号与热信号，了解了它们的特点。下一部分我们来看看为什么要区分冷信号与热信号。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[聊一聊RAC]]></title>
    <link href="http://williamzang.com/blog/2014/08/20/talk-about-rac/"/>
    <updated>2014-08-20T11:17:32+08:00</updated>
    <id>http://williamzang.com/blog/2014/08/20/talk-about-rac</id>
    <content type="html"><![CDATA[<p>今天来聊一聊RAC，这个在Github上很火热的开源框架，相信很多关注iOS前沿开发的人都或多或少的知道。</p>

<p>关于RAC的介绍和一些概念，我这里就不再啰嗦了，大家可以看   <a href="http://limboy.me/about.html">limboy</a>的几篇关于RAC的介绍，很不错。</p>

<blockquote><p><a href="http://limboy.me/ios/2013/06/19/frp-reactivecocoa.html">ReactiveCocoa与Functional Reactive Programming</a><br/>
<a href="http://limboy.me/ios/2013/12/27/reactivecocoa-2.html">说说ReactiveCocoa 2</a><br/>
<a href="http://limboy.me/ios/2014/01/05/ios-rest-client-implementation.html">基于AFNetworking2.0和ReactiveCocoa2.1的iOS REST Client</a><br/>
<a href="http://limboy.me/tech/2014/06/06/deep-into-reactivecocoa2.html">ReactiveCocoa2实战</a></p></blockquote>

<p>此外还有Cocoachina的一系列教程<a href="http://www.cocoachina.com/cms/plus/view.php?aid=8905">Reactive Cocoa详解</a></p>

<p>写Blog，在我看来和开发一样，也要讲究重用，引用列位的信息即可，何必黏贴和表达类似的观点。这里我也仅说一下我自己的理解和看法。</p>

<p>相信很多人都尝试过RAC用到一些小的DEMO或者项目中的一个小部分然后就浅尝辄止了。为什么呢？我觉得主要在于，RAC实际推行的一种新的概念大家还没有习惯，那就是函数响应式编程FRP。<a href="https://github.com/staltz">staltz</a>在一个Gist上倒是给了一个比较全面的解释<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">The introduction to Reactive Programming you&rsquo;ve been missing</a>，可惜是英文的。</p>

<p>这种FRP的核心就在于数据流，FRP把整个的程序认为是数据流的转换，既不是过程、也不是对象。一个系统先产生信号，转换信号，然后业务和界面再接收和响应信号的变化。所以，这是一个新的概念。如果使用别的概念套用，自然用起来就没那么顺手了。那么我们来看看，这样做的好处是什么呢？</p>

<ul>
<li>统一的流处理模式，使得不同的组件可以很好的结合起来，例如iOS的<code>UserDefault</code>、<code>NSNotificationCenter</code>、<code>KVO</code>这些，在RAC库下面，都是相同的封装，这样就使得上层的业务逻辑实现了<strong>大同</strong>，进而一切的信号转换合并都可以有效的结合在一起。</li>
<li>处理异步，很多时候，我们对于异步再同步是比较头大的。而RAC中，一个信号的终止，是不局限在一个函数中的。这样我们可以把不同线程、不同时期的状态绑到一个信号上，使得使用者达到一种内聚。和这种内聚，在转换和迭代的过程中是很必要的。</li>
<li>统一的错误处理，从古老的C时代的<code>int DoSomeThine(int input1, int *output1)</code>这种以返回值返回错误，到后来<code>SetErrorStatus(int ErrorCode, const char *message)</code>的线程栈内全局报错机制，还有现在try-catch机制，都有一个很要命的问题，就是错误处理，或者是可以被忽略，或者是让开发变得很烦恼。Java的try-catch机制，相信Java的开发者们一定深有感触。而RAC把错误变得简单了，它对于错误的处理，会随着变化一起传递到顶层，既不会忘记，也不用在中间环节中手动传递来传递去。</li>
<li>逻辑的拆分，在FRP中，逻辑变得相对独立，通常是一个模块，根据一定的变化产生一个信号，亦或是一个模块，根据一个传入的信号，产生一定的转换。这就使得，我们可以只返回我们的直接结果，后期的加工和变更是分离的。对于上层模块，也只关注信号的类型，不关注处于那个线程还是何种手法。</li>
</ul>


<p>总而言之，RAC给与我们以数据的变化作为出发点，界面与之响应的一套框架。详细的一些技巧，我会在后续的blog中为大家慢慢介绍。</p>
]]></content>
  </entry>
  
</feed>
